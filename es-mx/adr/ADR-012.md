# ADR-012: Límites de Ruteo del Core — Gateways, Registro de Capacidades, Autoridad de Leases y Orquestación de Tareas

**Status:** Borrador  
**Date:** 2026-01-08  
**Deciders:** @RichardRosenblat  
**Context:** límites del Core, supervisión del kernel, ejecución de módulos, autoridad de leases, estabilización de terminología

---

## Contexto

A medida que la arquitectura de ANIMA ha madurado, varias discusiones de diseño han convergido en un patrón estructural recurrente:

- El Core (Cognitive Kernel) debe **supervisar** trabajo, no ejecutarlo (ADR-008).
- El Core nunca debe ejecutar código de terceros; los Módulos corren fuera de proceso (ADR-010).
- Toda ejecución Core ↔ Módulo está controlada por leases y es segura por épocas (epoch-safe) (ADR-003).
- Entradas y observabilidad son basadas en eventos y con alcance por ejecución (ADR-004, ADR-011).
- Cortex es obligatorio y Arcuate es opcional; Arcuate es solo traductor (ADR-009).

Sin embargo, el código y las discusiones de diseño corren el riesgo de ambigüedad en términos como:

- “Gateway” (a veces usado como “host de lógica de dominio”)
- “ModuleRegistry” (a veces absorbiendo reglas de autorización)
- “TaskOrchestrator” (a veces absorbiendo política de dominio)

Este ADR estabiliza la terminología y los límites para que:

- ANIMA permanezca como un sistema hexagonal/DDD limpio
- la autorización permanezca inequívoca
- y el kernel no acumule lógica de negocio escondida

---

## Decisión

ANIMA adopta formalmente los siguientes contratos de límite (boundary contracts):

1. **Los Gateways del Core son límites de ruteo con un solo punto de entrada `send()`.**
   - Un Gateway despacha objetos de operación tipados hacia una implementación de puerto/cliente inyectada.
   - Un Gateway no contiene **política de dominio** y no realiza **I/O externo**.
   - La “implementación detrás del Gateway” DEBE tratarse como un **Puerto/Cliente** (puerto hexagonal), no como un bounded context de dominio.

2. **TaskOrchestrator es la columna vertebral de ejecución supervisada del Kernel, no un motor de política de ejecución.**
   - TaskOrchestrator gestiona el ciclo de vida (spawn/run/pause/cancel/complete), cooperación de interrupciones y agregación de resultados.
   - La política de dominio/aplicación (p. ej., “reglas de retry porque esta clase de intent es importante”) NO DEBE vivir en TaskOrchestrator.
   - Las decisiones de política deben vivir en componentes explícitos de política en la capa de dominio/aplicación adecuada y ser inyectadas.

3. **ModuleRegistry es autoridad de descubrimiento de capacidades y de conexión, no autoridad de autorización.**
   - ModuleRegistry descubre módulos, realiza handshake/attestation, rastrea liveness y provee lookup en runtime de endpoints de capacidades.
   - ModuleRegistry NO DEBE decidir si una capacidad está *permitida* para ejecutarse (eso pertenece a leases + política de seguridad).

4. **La autoridad de Lease es explícita y pertenece al Core.**
   - Emisión/renovación/revocación/actualización de scope/autoridad de epoch DEBE permanecer como un concepto dedicado del Core (“LeaseManager”).
   - Ningún otro componente (Registry, Port, Module) puede convertirse en la autoridad implícita de leases.
   - Esto refuerza estructuralmente ADR-003.

5. **Los puertos de módulo son sesiones ligadas a lease, no definiciones de comportamiento.**
   - Un ModulePort/Session representa una conexión de transporte opaca ligada a:
     - `LeaseMeta` (lease_id, epoch, proofs)
     - `ExecMeta` (execution_id, trace_id, span_id, thread_id)
   - Serializa solicitudes, adjunta lease meta + exec meta y maneja fallas de transporte.
   - No codifica semántica de negocio sobre *qué* hacer o *por qué*.

6. **El flujo event-first del kernel es canónico.**
   - El kernel consume eventos estructurados mediante la cola unificada de eventos (ADR-011).
   - Las transiciones de planeación y ejecución DEBEN emitir eventos estructurados (ADR-004).
   - Los “flujos de llamada directa” se permiten internamente por conveniencia de implementación, pero deben preservar el modelo conceptual:
     evento → razonar → intent → validar → agendar → invocar → observar.

---

## Definiciones

### 1) Gateway

Un Gateway del Core es un límite de ruteo que posee una implementación de puerto/cliente y expone un único punto de entrada:

- `send(operation) -> result`

Responsabilidades:
- aceptar objetos de operación
- despachar por tipo de operación
- aplicar restricciones del límite (tipado, ops permitidas, reglas “translator-only”, etc.)
- reenviar hacia una implementación de puerto/cliente inyectada

No-responsabilidades:
- ninguna política de dominio (no “¿debemos hacer X?”)
- ningún I/O de infraestructura

**Nota:** La implementación detrás del Gateway DEBERÍA llamarse `CortexPort`, `MemoryPort`, `ArcuateClient`, etc., para reducir confusión con bounded contexts.

---

### 2) CortexGateway / MTLGateway / ArcuateGateway

- **CortexGateway** enruta operaciones cognitivas hacia el Cortex obligatorio vía puerto/cliente (ADR-009).
- **MTLGateway** enruta operaciones de memoria hacia puertos MTL (repositorios, servicios de memoria) sin incrustar política de memoria.
- **ArcuateGateway** enruta operaciones de traducción NLP hacia Arcuate (si está presente) y DEBE permanecer translator-only (ADR-009).

---

### 3) Objetos de Operación

Los Gateways operan sobre objetos de operación tipados. Las Ops representan “qué comportamiento” sin codificar cómo ocurre el ruteo.

Categorías de ejemplo:
- `ProcessEvent`
- `EvaluateIntent`
- `Reflect`
- `TranslateInputNlToSemantic`
- `RealizeIntentToNl`

---

### 4) ModuleRegistry

ModuleRegistry es la autoridad para:
- discovery
- rastreo de attestation/handshake
- rastreo de liveness
- indexación de capacidades
- retornar un handle vivo de endpoint para una capacidad

No es la autoridad para:
- permissioning
- otorgamiento de leases
- promoción/degradación de scope

---

### 5) LeaseManager (Propiedad del Core)

LeaseManager es un componente dedicado del Core responsable de:
- emitir leases
- renovar leases
- revocar leases
- gestionar epochs
- reforzar la semántica “sin lease, no hay ejecución” (ADR-003)

LeaseManager es el único componente permitido para mutar el estado de lease.

---

### 6) ModulePort / ModuleSession

Un ModulePort/Session representa:
- una conexión de transporte ligada a:
  - `LeaseMeta` (lease_id, epoch)
  - `ExecMeta` (contexto de ejecución/trace/span)
- una superficie opaca de invocación:
  - `invoke(capability_urn, payload, meta) -> result`

Responsabilidades:
- serialización/deserialización
- adjuntar metadatos requeridos
- retries por falla de transporte (si se configura)
- exponer errores de forma determinista

No-responsabilidades:
- decidir semántica de negocio
- decidir autorización
- decidir políticas como “cuántos retries porque es importante”

---

### 7) TaskOrchestrator

TaskOrchestrator es la columna vertebral de ejecución supervisada del Kernel.

Responsabilidades:
- gestionar ciclo de vida de tareas/spans (spawn/run/pause/cancel/complete) (ADR-008)
- cooperar con ruteo y políticas de interrupción (ADR-005)
- resolver capacidades vía ModuleRegistry
- obtener/validar contexto de lease vía LeaseManager antes de invocar (ADR-003)
- despachar tareas hacia ModulePorts
- agregar resultados y emitir eventos (ADR-004)

No-responsabilidades:
- codificar política de dominio (p. ej., retry específico por significado del intent)
- incrustar lógica de planeación (eso pertenece a cognición/Cortex)
- saltarse la autoridad de lease

---

## Flujo Conceptual Canónico

```text
Evento de Entrada
  ↓ (cola de eventos; ADR-011)
El Core consume el evento
  ↓
CortexGateway.send(ProcessEvent(event))
  ↓
Grafo de Intents
  ↓ (decisiones de seguridad / permisos / leases)
TaskOrchestrator agenda trabajo
  ↓
ModuleRegistry resuelve capacidad → ModulePort/Session
  ↓
LeaseManager asegura lease válido + epoch
  ↓
ModulePort.invoke(capability_urn, payload, exec_meta, lease_meta)
  ↓
Module Adapter → Module Actuator
  ↓
Efectos en el mundo + eventos estructurados (ADR-004)
```

---

## Consecuencias

### Positivas

- Evita “policy creep” escondido en componentes de ruteo y agendamiento del Core
- Hace explícita y auditable la autoridad de leases (refuerza ADR-003)
- Estabiliza terminología para que “Gateway/Registry/Orchestrator” no derive
- Preserva límites hexagonales: puertos en dominios, adapters en infra/runtime
- Hace consistente la migración de IPC (in-process ahora, gRPC después)

### Trade-offs

- Más componentes explícitos (LeaseManager, inyección de política) vs. “meterlo en el orchestrator”
- Un poco más de wiring en runtime/composition root
- Requiere disciplina en naming (“Port/Client” vs “Implementation”) para evitar deriva conceptual

---

## ADRs Relacionados

- ADR-003 — Protocolo Core ↔ Module, tipos de módulo, leases
- ADR-004 — Modelo de observabilidad y envelope de eventos
- ADR-005 — Modelo de interrupción & preempción
- ADR-008 — Core como cognitive kernel (supervisa, no ejecuta)
- ADR-009 — Cortex obligatorio, Arcuate opcional + restricción translator-only
- ADR-010 — Adapter–Actuator split; sin código de terceros en Core
- ADR-011 — Arquitectura de input basada en eventos

---

## Declaración Final

Gateways rutean.  
Registry descubre.  
LeaseManager autoriza.  
TaskOrchestrator supervisa la ejecución.  
Cortex decide.

Esta separación es obligatoria para preservar el modelo de kernel de ANIMA, invariantes de seguridad y mantenibilidad a largo plazo.