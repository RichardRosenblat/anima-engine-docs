# ADR-010: División Adaptador–Actuador con Frontera de Proceso Estricta (Sin Código de Terceros en el Núcleo)

**Estado:** Aceptado  
**Fecha:** 2026-01-07  
**Decisores:** @RichardRosenblat  
**Contexto:** Seguridad, Aislamiento, Arquitectura Hexagonal, DDD

---

## Contexto

ANIMA integra Módulos externos para percibir entradas y ejecutar efectos secundarios. Los diseños iniciales consideraban cargar Python propiedad del módulo en el Núcleo para traducción ("adaptadores"). Eso es una violación de seguridad: el Núcleo nunca debe ejecutar código de terceros.

Para preservar seguridad y fronteras hexagonales mientras mantenemos los Módulos prácticos para distribuir, dividimos responsabilidades de módulo y aplicamos una frontera de proceso estricta.

---

## Decisión

Cada Módulo se divide en dos partes, ambas ejecutándose fuera del proceso del Núcleo:

- Adaptador — Traducción pura y validación de schema
- Actuador — Ejecución con efectos que toca APIs/hardware

El Núcleo nunca carga ni ejecuta código propiedad del módulo. Toda interacción Núcleo ↔ Módulo ocurre vía gRPC con mTLS y leases emitidos por el Núcleo (ADR-003).

---

## Definiciones

### Adaptador (Lado del Módulo, Traducción Pura)
- Ruta de entrada: mapea señales capturadas → eventos de entrada del Núcleo 
- Ruta de salida: mapea Intención del Núcleo (URN de capacidad + payload) → schema de comando del módulo
- Responsabilidades:
  - traducción determinística
  - validación de JSON Schema contra el contrato de capacidad
  - aplicación de alcance de lease en llamadas de salida
- Prohibiciones:
  - sin planificación, sin política
  - sin I/O externo más allá de gRPC hacia el Núcleo o invocación de actuador local
  - sin acceso a la memoria o internos del Núcleo

### Actuador (Lado del Módulo, Ejecución con Efectos)
- Ejecuta efectos secundarios del mundo real (APIs, hardware, plataformas)
- Aplica políticas de alcance de lease e interrupción (ADR-005)
- Emite eventos de observabilidad con sobre ADR-004
- Contiene cero lógica o razonamiento del Núcleo

---

## Frontera de Proceso (Invariante)

- Núcleo ejecuta solo código confiable, propiedad del motor.
- Adaptadores y Actuadores ejecutan en procesos propiedad del módulo.
- Toda comunicación usa gRPC sobre mTLS con identidades atestiguadas (URN del Núcleo, URN del Módulo) y leases emitidos por el Núcleo (ADR-003).
- Sin importaciones dinámicas, plugins o ejecución de Python de módulos dentro del Núcleo.

---

## Propiedad de PLN en Módulos de Lenguaje Natural

Los módulos que manejan entrada y salida de lenguaje natural PUEDEN enviar una implementación de PLN o delegar responsabilidades de PLN al Arcuate del Núcleo (ADR-009). Esta elección debe preservar aislamiento de proceso y la división Adaptador–Actuador.

### Entrada de Lenguaje Natural
- Opción A — PLN propiedad del módulo:
  - El Adaptador del módulo realiza PLN local para transformar input.nl → eventos input.semantic.
  - Restricciones:
    - Solo traducción; sin planificación o política
    - Incluir confianza y procedencia en payloads semánticos
    - Sin acceso a la memoria del Núcleo; procedencia refleja "module"
- Opción B — Delegar al Arcuate:
  - El Adaptador del módulo publica eventos input.nl al Núcleo.
  - El Arcuate del Núcleo consume input.nl y produce input.semantic; Núcleo razona sobre eventos semánticos.
  - Restricciones:
    - Adaptador permanece puro; sin PLN incorporado
    - Frontera de proceso preservada; sin código de plugin en el Núcleo

### Salida de Lenguaje Natural (ej., TTS, entrega de chat)
- Opción A — GNL propiedad del módulo:
  - El Adaptador del módulo mapea intenciones del Núcleo a schemas de comando de salida y realiza GNL local (realización de superficie) antes de la ejecución del Actuador (ej., síntesis TTS, envío de mensaje).
  - Restricciones:
    - GNL es traducción; sin planificación, sin acceso a la memoria
    - Eventos de observabilidad DEBEN capturar intención, metadatos de realización y resultado de ejecución
- Opción B — Delegar al Arcuate:
  - El Núcleo produce la superficie lingüística vía Arcuate desde el contenido semántico de una intención.
  - El Adaptador del módulo traduce el texto realizado en el comando del módulo; el Actuador ejecuta (ej., hablar/enviar).
  - Restricciones:
    - Adaptador permanece puro; Actuador realiza efectos secundarios
    - Uso del Arcuate sigue reglas de aislamiento ADR-009

En todos los casos:
- Adaptadores permanecen mapeo puro + validación.
- Actuadores realizan IO y efectos bajo leases válidos (ADR-003).
- Eventos semánticos DEBEN incluir campos de confianza y procedencia (ADR-011).
- Lenguaje natural NO DEBE activar ejecución directa; el pipeline permanece Entrada → Interpretación → Intención → Validación/Confirmación → Ejecución (Modelo de Seguridad).

---

## Protocolo & Contratos

- Entrada (Módulo → Núcleo): Adaptador publica eventos de entrada y tipos de evento.
- Salida (Núcleo → Módulo): Núcleo llama al Adaptador vía un Gateway de Capacidad genérico:
  - capability_urn + schema_version + payload (validado por el adaptador)
  - LeaseMeta (lease_id, epoch) y ExecMeta (execution/trace/span)
- Contrato de Capacidad:
  - JSON Schemas declarativos para payloads de comando
  - clase de efecto secundario del método (reversible/irreversible)
  - política de interrupción (soft-stop/hard-stop/checkpoint/non-interruptible)
  - duración máxima de lease

---

## Invariantes de Seguridad

- Sin código de plugin en el Núcleo — nunca.
- Toda ejecución de módulo requiere un lease válido con epoch actual (ADR-003).
- Promoción/degradación de alcance ocurre solo vía actualizaciones de lease emitidas por el Núcleo.
- Estado Zero-Lease: módulos están inertes (Type II standby o Type I terminate).
- Adaptadores no pueden ampliar alcance o evitar protección del Núcleo.

---

## Observabilidad

- Adaptadores y Actuadores emiten eventos estructurados por ADR-004:
  - execution_id, trace_id, span_id, thread_id, timestamp
  - instance_urn, core_urn
  - source=module:<name> y type=
  - payload=solo campos estructurados
- Sin logs de texto libre como autoridad; eventos son la fuente de la verdad.

---

## Patrón de Empaquetado (De Propiedad del Módulo, Organizado en Capas Limpias)

Un módulo puede distribuir Adaptador y Actuador juntos mientras preserva pureza:

- adapter/
  - input/  (señales → eventos input.*; mapeo puro)
  - output/ (intención → comandos; mapeo puro + validación de schema)
- actuator/ (ejecución con efectos: APIs/hardware)
- capability_contract/ (JSON Schemas + manifiesto)
- transport/ (servidor/cliente gRPC; mTLS; aplicación de lease)
- proto/ (IDL para CapabilityGateway y servicios Adapter)

---

## Consecuencias

### Positivas
- Elimina riesgo de inyección de código en el Núcleo
- Preserva fronteras hexagonales y testeabilidad
- División clara de responsabilidades (traducir vs ejecutar)
- Fuerte auditabilidad vía eventos estructurados

### Tradeoffs
- Requiere disciplina estricta de schema y validación de manifiesto
- Ligeramente más cableado (gRPC + ciclo de vida de lease)

---

## ADRs Relacionados

- ADR-003 — Protocolo Núcleo ↔ Módulo, tipos de módulo, leases
- ADR-004 — Modelo de observabilidad y sobre de evento
- ADR-005 — Modelo de interrupción & preempción
- ADR-007 — Reglas de infraestructura & adaptador
- ADR-011 — Arquitectura de entrada basada en eventos

---

## Declaración Final

Núcleo razona y supervisa. Módulos adaptan y actúan.  
Sin código de terceros se ejecuta dentro del Núcleo.
