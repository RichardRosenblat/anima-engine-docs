# ADR-006: Reglas de Dependencia y Compartición de Dominio

**Estado:** Aceptado  
**Fecha:** 2026-01-04  
**Decisores:** @Richard Rosenblat  
**Contexto:** Arquitectura Hexagonal, Domain-Driven Design (DDD), Python  

---

## Contexto

ANIMA sigue **Arquitectura Hexagonal** combinada con **Domain-Driven Design (DDD)**. A medida que el sistema crece, la ambigüedad en torno a *qué pueden compartir los dominios* y *cómo pueden fluir las dependencias* crea riesgo arquitectónico.

Python aumenta este riesgo debido a:

* Encapsulación débil a nivel de módulo
* Fácil acceso a implementaciones concretas
* Falta de límites aplicados por defecto

Este ADR formaliza **reglas estrictas y explícitas** que gobiernan:

* Dependencias de dominio a dominio
* Qué puede compartirse
* Cuándo las implementaciones concretas pueden cruzar límites de dominio
* Cómo debe ocurrir la conexión en runtime

El objetivo es **claridad, consistencia y mantenibilidad a largo plazo**.

---

### Decisión

Los dominios **no comparten código libremente**.
Los dominios solo pueden depender de otros dominios a través de **contratos públicos explícitos**.

Todo uso entre dominios debe encajar en **una de las formas de dependencia aprobadas** definidas a continuación.

Cualquier cosa no explícitamente permitida está **prohibida por defecto**.

---

### Formas de Dependencia Entre Dominios Aprobadas

Un dominio puede exponer lo siguiente como parte de su **API pública**:

#### 1. Funciones Libres (Lógica de Dominio Sin Estado)

Usadas para:

* Reglas determinísticas
* Análisis, validación, generación
* Transformaciones de valor

**Características:**

* Puras o casi puras
* Sin ciclo de vida
* Sin IO externo

**Ejemplo (dominio URN):**

```python
## domains/urn/generate.py

def generate_urn() -> URN:
    ...
```

```python
## domains/core/process.py
from domains.urn import generate_urn

class CoreProcess:
    def __init__(self) -> None:
        self.urn = generate_urn()
```

✔ Permitido

---

#### 2. Envoltorios de Tipo Primitivo / Objetos de Valor

Usados para codificar **significado semántico** y prevenir el mal uso de primitivos.

**Ejemplos:**

* `URN`
* `ExecutionId`
* `TraceId`
* `ParsedURN`

```python
## domains/urn/types.py
from typing import NewType

URN = NewType("URN", str)
```

✔ Permitido

Los objetos de valor son seguros para importar directamente entre dominios.

---

#### 3. Clases Base (Conceptualmente Abstractas)

Las clases base definen **invariantes y contratos**.

##### 3.1 Clases Base Comportamentales → DEBEN ser Abstractas

Usadas cuando:

* Otros dominios especializan comportamiento
* La clase no debe instanciarse

```python
from abc import ABC, abstractmethod

class BaseProcess(ABC):
    @abstractmethod
    def run(self) -> None:
        ...
```

✔ Permitido

---

##### 3.2 Clases Base de Excepción → PUEDEN ser Concretas

Las excepciones son **valores**, no comportamientos.

Ellas:

* Deben ser instanciables
* Codifican semántica de dominio
* Están explícitamente diseñadas para herencia

```python
class DomainError(Exception):
    pass

class URNError(DomainError):
    pass
```

✔ Permitido

Esta es una excepción intencional a las reglas de abstracción.

---


##### 3.3 Traducción de Error Entre Dominios (Obligatoria)

Cuando un dominio depende de otro dominio e invoca su API pública, **los errores específicos del dominio originados de la dependencia NO DEBEN filtrarse sin modificación**.

En su lugar:

* El dominio consumidor **DEBE capturar** errores del dominio de dependencia
* El dominio consumidor **DEBE lanzar su propio error específico de dominio**
* El error lanzado **DEBE heredar del tipo de error original**
* El error lanzado **DEBE preservar la excepción original como causa**

Esto garantiza:

* Cada dominio permanece como la **autoridad semántica** sobre sus propios modos de falla
* El significado del error se **reformula en el lenguaje del dominio consumidor**
* Se preserva el linaje de excepción y la capacidad de captura

###### Ejemplo

```python
# domains/urn/errors.py
class URNError(DomainError):
    pass
```

```python
# domains/order/errors.py
from domains.urn.errors import URNError

class OrderURNResolutionError(URNError):
    pass
```

```python
# domains/order/service.py
from domains.urn import generate_urn
from domains.urn.errors import URNError
from domains.order.errors import OrderURNResolutionError

def create_order() -> None:
    try:
        urn = generate_urn()
    except URNError as exc:
        raise OrderURNResolutionError(
            "Failed to generate URN during order creation"
        ) from exc
```

✔ Permitido
✔ Requerido
✔ Explícito

---


#### 4. Interfaces / Protocolos

Usadas cuando:

* El comportamiento debe proporcionarse externamente
* Múltiples implementaciones son posibles
* Se requiere conexión en runtime

```python
from typing import Protocol

class Clock(Protocol):
    def now(self) -> datetime: ...
```

```python
class CoreProcess:
    def __init__(self, clock: Clock):
        self.clock = clock
```

✔ Permitido

Los dominios dependen de **interfaces**, no implementaciones.

---

### Implementaciones Concretas Entre Dominios

Las implementaciones concretas pueden cruzar límites de dominio **solo en los siguientes casos**:

#### Caso 1 — Objetos de Valor

Inmutables, autocontenidos, sin ciclo de vida.

✔ Siempre permitido

---

#### Caso 2 — Errores

Las clases de excepción concretas están explícitamente permitidas para compartirse y heredarse.

Sin embargo:

* **Los errores originados de otro dominio no deben escapar del dominio consumidor sin modificación**
* Los dominios **deben traducir errores de dependencia** en sus propios errores específicos de dominio
* El error traducido **debe heredar del tipo de error original**

✔ Permitido
✔ Requerido para límites entre dominios

---

#### Caso 3 — Servicios de Dominio Autoritativos

Si un dominio es la **autoridad semántica** sobre un comportamiento, otros dominios pueden importar su implementación concreta.

**Ejemplo:**

* La generación de URN pertenece exclusivamente al dominio URN

```python
from domains.urn import generate_urn
```

✔ Permitido **solo si**:

* La implementación es intencionalmente pública
* El comportamiento es estable
* No hay estado de runtime o IO involucrado

---

### Prácticas Prohibidas Entre Dominios

❌ Importar módulos internos o helpers privados  
❌ Compartir estado mutable entre dominios  
❌ Importar implementaciones de infraestructura directamente  
❌ Dependencias circulares de dominio  
❌ Conexión en runtime dentro de la lógica de dominio  

Ejemplo (PROHIBIDO):

```python
from domains.storage.postgres import PostgresRepository
```

---

### Reglas de Capa Compartida

Algunas abstracciones no pertenecen a ningún dominio.

```
/shared
  #types.py        # ExecutionId, TraceId
  #protocols.py    # Clock, Logger, EventSink
  #base.py         # Clases base abstractas
```

Reglas:

* Los dominios pueden depender de `shared`
* `shared` no depende de nada

---

### Responsabilidades del Runtime

Runtime es responsable de:

* Instanciar implementaciones concretas
* Conectar dependencias
* Seleccionar estrategias

Dominios:

* Nunca deben instanciar infraestructura
* Nunca deben seleccionar implementaciones

---

### Reglas Resumidas (No Negociables)

1. Los dominios comparten **contratos**, no internos
2. Los contratos pueden ser:

   * Funciones
   * Objetos de valor
   * Clases base abstractas
   * Interfaces / protocolos
3. Los errores son instanciables y heredables
4. Las implementaciones concretas cruzan dominios solo si son:

   * Valores
   * Errores
   * Servicios autoritativos puros
5. Runtime ensambla el sistema
6. Los errores de dominio de dependencias DEBEN capturarse y relanzarse como errores específicos de dominio que heredan el tipo de error original
---

## Consecuencias

* Límites arquitectónicos fuertes
* Acoplamiento accidental reducido
* Grafo de dependencias predecible
* Pruebas y refactorización más fáciles
* Rigor inicial aumentado

Este rigor es intencional y necesario.

---

## Principio Final

> **Los dominios no dependen de implementaciones.
> Dependen de significado.**

El significado se expresa a través de contratos.
