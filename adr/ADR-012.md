# ADR-012: Core Routing Boundaries — Gateways, Capability Registry, Lease Authority, and Task Orchestration

**Status:** Draft  
**Date:** 2026-01-08  
**Deciders:** @RichardRosenblat  
**Context:** Core boundaries, kernel supervision, module execution, lease authority, terminology stabilization

---

## Context

As ANIMA’s architecture has matured, several design discussions have converged on a recurring structural pattern:

- The Core (Cognitive Kernel) must **supervise** work, not execute it (ADR-008).
- The Core must never run third-party code; Modules run out-of-process (ADR-010).
- All Core ↔ Module execution is lease-gated and epoch-safe (ADR-003).
- Inputs and observability are event-based and execution-scoped (ADR-004, ADR-011).
- Cortex is mandatory and Arcuate is optional; Arcuate is translator-only (ADR-009).

However, the codebase and design discussions risk ambiguity around terms like:

- “Gateway” (sometimes used as “domain logic host”)
- “ModuleRegistry” (sometimes absorbing authorization rules)
- “TaskOrchestrator” (sometimes absorbing domain policy)

This ADR stabilizes terminology and boundaries so that:
- ANIMA remains a clean hexagonal/DDD system,
- authorization remains unambiguous,
- and the kernel does not accumulate hidden business logic.

---

## Decision

ANIMA formally adopts the following boundary contracts:

1. **Core Gateways are routing boundaries with a single `send()` entry point.**
   - A Gateway dispatches typed operation objects to an injected port/client implementation.
   - A Gateway contains **no domain policy** and **no external I/O**.
   - “Implementation” behind a Gateway MUST be treated as a **Port/Client** (hexagonal port), not a domain bounded context.

2. **TaskOrchestrator is the Kernel’s supervised execution spine, not an execution-policy engine.**
   - TaskOrchestrator manages lifecycle (spawn/run/pause/cancel/complete), interruption cooperation, and outcome aggregation.
   - Domain/application policy (e.g., “retry rules because this class of intent is important”) MUST NOT live in TaskOrchestrator.
   - Policy decisions must live in explicit policy components in the appropriate domain/application layer and be injected.

3. **ModuleRegistry is capability discovery and connection authority, not authorization authority.**
   - ModuleRegistry discovers modules, performs handshake/attestation, tracks liveness, and provides runtime lookup of capability endpoints.
   - ModuleRegistry MUST NOT decide whether a capability is *permitted* to execute (that is lease + security policy territory).

4. **Lease Authority is explicit and Core-owned.**
   - Lease issuance/renewal/revocation/scope update/epoch authority MUST remain a dedicated Core concept (“LeaseManager”).
   - No other component (Registry, Port, Module) may become the implicit lease authority.
   - This is a structural reinforcement of ADR-003.

5. **Module ports are lease-bound sessions, not behavior definitions.**
   - A ModulePort/Session represents an opaque transport connection to a module.
   - It serializes requests, attaches lease meta + exec meta, and handles transport failures.
   - It does not encode business semantics about *what* to do or *why*.

6. **Event-first kernel flow is canonical.**
   - The kernel consumes structured events via the unified event queue (ADR-011).
   - Planning and execution transitions MUST emit structured events (ADR-004).
   - “Direct call flows” are allowed internally for implementation convenience, but must preserve the conceptual model:
     event → reason → intent → validate → schedule → invoke → observe.

---

## Definitions

### 1) Gateway

A Core Gateway is a routing boundary that owns a port/client implementation and exposes a single entry point:

- `send(operation) -> result`

Responsibilities:
- accept operation objects
- dispatch by operation type
- enforce boundary constraints (typing, allowed ops, “translator-only” rules, etc.)
- forward to an injected port/client implementation

Non-responsibilities:
- no domain policy (no “should we do X?”)
- no infrastructure I/O

**Note:** A Gateway’s backing implementation SHOULD be named like `CortexPort`, `MemoryPort`, `ArcuateClient`, etc. to reduce confusion with domain bounded contexts.

---

### 2) CortexGateway / MemoryGateway / ArcuateGateway

- **CortexGateway** routes cognitive operations to the mandatory Cortex port/client (ADR-009).
- **MemoryGateway** routes memory operations to memory ports (repositories, memory services) without embedding memory policy.
- **ArcuateGateway** routes NLP translation operations to Arcuate (if present) and MUST remain translator-only (ADR-009).

---

### 3) Operation Objects

Gateways operate on typed operation objects. Ops represent “which behavior” without encoding how routing occurs.

Example categories:
- `ProcessEvent`
- `EvaluateIntent`
- `Reflect`
- `TranslateInputNlToSemantic`
- `RealizeIntentToNl`

---

### 4) ModuleRegistry

The ModuleRegistry is the authority for:
- discovery
- attestation/handshake tracking
- liveness tracking
- capability indexing
- returning a live endpoint handle for a capability

It is not the authority for:
- permissioning
- lease granting
- scope promotion/demotion

---

### 5) LeaseManager (Core-Owned)

LeaseManager is a dedicated Core component responsible for:
- issuing leases
- renewing leases
- revoking leases
- managing epochs
- enforcing “no lease, no execution” semantics (ADR-003)

LeaseManager is the only component allowed to mutate lease state.

---

### 6) ModulePort / ModuleSession

A ModulePort/Session represents:
- a transport connection bound to:
  - `LeaseMeta` (lease_id, epoch, proofs)
  - `ExecMeta` (execution_id, trace_id, span_id, thread_id)
- an opaque invocation surface:
  - `invoke(capability_urn, payload, meta) -> result`

Responsibilities:
- serialization/deserialization
- attaching required metadata
- retries for transport failure (if configured)
- surfacing errors deterministically

Non-responsibilities:
- deciding business semantics
- deciding authorization
- deciding policies such as “how many retries because it’s important”

---

### 7) TaskOrchestrator

TaskOrchestrator is the Kernel’s supervised execution spine.

Responsibilities:
- manage task/span lifecycle (spawn/run/pause/cancel/complete) (ADR-008)
- cooperate with interruption routing and policies (ADR-005)
- resolve capabilities via ModuleRegistry
- obtain/validate lease context via LeaseManager before invocation (ADR-003)
- dispatch tasks to ModulePorts
- aggregate outcomes and emit events (ADR-004)

Non-responsibilities:
- encoding domain policy (e.g., intent-specific “retry because of business meaning”)
- embedding planning logic (that belongs in cognition/Cortex)
- bypassing lease authority

---

## Canonical Conceptual Flow

```text
Input Event
  ↓ (event queue; ADR-011)
Core consumes event
  ↓
CortexGateway.send(ProcessEvent(event))
  ↓
Intent Graph
  ↓ (security / permissioning / lease decisions)
TaskOrchestrator schedules work
  ↓
ModuleRegistry resolves capability → ModulePort/Session
  ↓
LeaseManager ensures valid lease + epoch
  ↓
ModulePort.invoke(capability_urn, payload, exec_meta, lease_meta)
  ↓
Module Adapter → Module Actuator
  ↓
World effects + structured events (ADR-004)
```

---

## Consequences

### Positive

- Prevents “hidden policy creep” into Core routing and scheduling components
- Makes lease authority explicit and auditable (reinforces ADR-003)
- Stabilizes terminology so “Gateway/Registry/Orchestrator” meanings do not drift
- Preserves hexagonal boundaries: ports in domains, adapters in infra/runtime wiring
- Makes IPC migration (in-process now, gRPC later) mechanically consistent

### Trade-offs

- More explicit components (LeaseManager, policy injection) vs. “just put it in orchestrator”
- Slightly more wiring in runtime/composition root
- Requires discipline in naming (“Port/Client” vs “Implementation”) to prevent conceptual drift

---

## Related ADRs

- ADR-003 — Core ↔ Module protocol, leases, epochs, module types
- ADR-004 — Event-based observability and execution scoping
- ADR-005 — Interruption & preemption model
- ADR-008 — Core behaves as a cognitive kernel (supervises, doesn’t execute)
- ADR-009 — Cortex mandatory, Arcuate optional + translator-only constraint
- ADR-010 — Adapter–Actuator split; no third-party code in Core
- ADR-011 — Event-based input architecture

---

## Final Statement

Gateways route.  
Registry discovers.  
LeaseManager authorizes.  
TaskOrchestrator supervises execution.  
Cortex decides.

This separation is mandatory to preserve ANIMA’s kernel model, security invariants, and long-term maintainability.