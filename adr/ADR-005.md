# ADR-0005: Interruption & Preemption Model

**Status:** Accepted
**Date:** 2026-01-03
**Deciders:** @Richard Rosenblat
**Context:** Interaction, Safety, Real-Time Control, Observability, Determinism

---

## Context

ANIMA is designed to operate in **live, interactive environments** where users, systems, and sensors may provide input while the instance is already:

* speaking
* reasoning
* executing a plan
* invoking long-lived capabilities
* interacting with the external world

In such environments, **interruptions are inevitable**.

Naive interruption handling (e.g. thread killing, hard cancels, ad-hoc flags) introduces severe risks:

* inconsistent internal state
* partially executed actions
* lost auditability
* nondeterministic behavior
* unsafe external side effects

Therefore, ANIMA requires a **formal, deterministic, observable interruption model** that preserves safety and architectural clarity while enabling natural interaction.

---

## Decision

### 1. Interruptions Are First-Class Events

Interruptions are **not exceptions**, signals, or side-channels.

All interruptions MUST enter the system as **structured input events**, processed by the Core like any other input.

Examples include:

* user speech while ANIMA is speaking
* user commands issued mid-execution
* system safety triggers
* capability-emitted alerts

Interruptions MUST be:

* observable
* auditable
* replayable
* attributable to a source

---

### 2. Execution Model: Spans & Focus

All Core activity is represented as **execution spans**, each with:

* a unique `span_id`
* an associated `execution_id`
* a declared `interruptible` flag
* an interruption policy

At any moment, the Core maintains a **foreground focus span**.

By default:

* only the foreground span may be interrupted
* background work continues unless explicitly escalated

This prevents uncontrolled cascade cancellation.

---

### 3. Interruptibility Is Explicit

No action is interruptible by default.

Only spans that explicitly declare:

```yaml
interruptible: true
```

may be interrupted.

This includes, but is not limited to:

* speech streaming
* listening
* movement
* waiting
* long-lived capability execution

Non-interruptible spans MUST ignore interruption events.

---

### 4. Interruption Classification

Upon receiving an interruption event, the Core MUST classify it before acting.

Supported interruption classes include:

| Class           | Semantics                               |
| --------------- | --------------------------------------- |
| `override`      | Replace current foreground execution    |
| `cancel`        | Stop the current execution              |
| `queue`         | Defer until current execution completes |
| `clarification` | Interrupt to request clarification      |
| `emergency`     | Immediate halt, bypassing normal flow   |

Classification is a **reasoning step**, not a reflex.

---

### 5. Capability Interruption Policies

Capabilities that expose interruptible methods MUST declare an **interruption policy** per method.

Supported policies include:

| Policy              | Behavior                                  |
| ------------------- | ----------------------------------------- |
| `soft-stop`         | Stop at a safe boundary (e.g. buffer end) |
| `hard-stop`         | Immediate termination                     |
| `checkpointed`      | Roll back to last known safe checkpoint   |
| `non-interruptible` | Reject all interruptions                  |

The Core MUST respect declared policies.
Capabilities MUST enforce them locally.

---

### 6. Interruption Handling Flow

When an interruption occurs:

1. An interruption input event is emitted
2. The Core evaluates:

   * current foreground span
   * interruptibility
   * interruption classification
   * security & confidence thresholds
3. If permitted:

   * the target span is marked `interrupted`
   * an interruption directive is sent to the capability (if applicable)
4. The interrupted span:

   * terminates according to its policy
   * emits completion or cancellation events
5. A **new execution trace** begins

Interrupted traces are **never mutated or deleted**.

---

### 7. Speaking While Speaking (Canonical Case)

If ANIMA is actively speaking and user speech is detected:

* speech detection enters as an interruption event
* the Core evaluates confidence and permissions
* if classified as `override` or `cancel`:

  * the speech span is interrupted
  * the voice capability performs a `soft-stop`
  * control returns to the Core
  * a new execution begins

No hard process termination is permitted.

---

### 8. Security & Abuse Mitigation

Interruptions may be malicious or accidental.

The Core MUST enforce:

* confidence thresholds (e.g. speech certainty)
* rate limits
* role-based permissions
* escalation rules for emergency interruptions

Examples:

* only privileged roles may issue `emergency` interruptions
* low-confidence inputs may be queued or ignored

---

### 9. Observability & Traceability

All interruptions MUST generate timeline events, including:

* interruption source
* target span
* classification
* policy applied
* outcome

This integrates directly with the event-based observability model defined in ADR-004.

Interruptions MUST be clearly visible in execution timelines.

---

## Consequences

### Positive

* Natural, human-like interaction
* Deterministic interruption behavior
* Strong safety guarantees
* Full auditability and replayability
* Clean separation between input, reasoning, and execution

### Negative

* Increased modeling complexity
* Requires explicit capability design
* More upfront discipline in execution modeling

These tradeoffs are intentional.

---

## Non-Goals

This ADR does **not** define:

* UI/UX interaction patterns
* speech recognition confidence algorithms
* hardware-level interrupt handling
* real-time OS scheduling

These are delegated to modules and infrastructure layers.

---

## Summary

> **Interruptions in ANIMA are structured, classified input events that preempt execution in a controlled, observable, and deterministic manner.**

They are:

* explicit
* policy-governed
* auditable
* safe by construction

This model enables real-time interaction without sacrificing architectural integrity.
