# ADR-002: Self-Validating Schemas with Internal-Only Constraints

## Status
**Status:** Accepted
**Date:** 2025-12-31
**Deciders:** @Richard Rosenblat
**Context:** Schema design, domain purity, data integrity

## Context

ANIMA relies heavily on structured data schemas to define:

- memory records
- intent representations
- plans and semantic structures
- seed definitions
- capability descriptors

These schemas form the **foundation of the engine’s correctness**.  
Invalid or internally inconsistent data at this level can compromise safety, identity continuity, and reasoning integrity.

At the same time, ANIMA follows a strict hexagonal architecture, where:

- schemas belong to the **pure domain layer**
- domain code must not depend on external systems, state, or IO

This raises the question:

> Should schemas be allowed to validate themselves, and if so, under what constraints?

---

## Decision

Schemas **MAY** include self-validation logic **only if**:

1. The validation:
   - uses **only the data contained within the schema instance**
   - relies exclusively on pure logic
2. The validation:
   - does **not** query external state
   - does **not** depend on other schemas’ runtime instances
   - does **not** perform IO, filesystem access, or network calls
3. The validation:
   - is deterministic
   - produces the same result for the same input data

Schemas **MUST NOT** perform validation that requires:

- database access
- memory stores
- engine state
- user history
- model inference
- time-based or environment-based conditions

If validation requires external data or context, it **MUST** be implemented in a higher layer (e.g. seed validators, engine services, or security policies).

---

## Examples

### ✅ Allowed (Internal Consistency)

- Field range checks
- Enum membership validation
- Cross-field consistency within the same schema
- Structural integrity rules

```python
@dataclass(frozen=True)
class SemanticFact:
    content: str
    confidence: float

    def validate(self) -> None:
        if not (0.0 <= self.confidence <= 1.0):
            raise ValueError("confidence must be between 0 and 1")
````

### ❌ Forbidden (External Dependency)

* Checking whether a referenced entity exists in memory
* Verifying permissions
* Looking up historical interactions
* Calling engine services or adapters

```python
# ❌ Not allowed in schema
def validate(self, memory_store):
    if not memory_store.exists(self.reference_id):
        ...
```

---

## Rationale

Allowing **internal-only validation** provides:

* Early error detection
* Stronger data guarantees
* Clear ownership of invariants
* Reduced propagation of invalid state

Restricting schemas to **self-contained validation** preserves:

* Purity of the domain layer
* Testability
* Deterministic behavior
* Clean dependency flow inward

This balances safety and architectural discipline without turning schemas into mini-services.

---

## Consequences

### Positive

* Schemas are robust and self-defensive
* Invalid data fails fast and locally
* Core engine logic can trust schema invariants

### Negative

* Some validation logic must be duplicated or deferred to higher layers
* Developers must think carefully about validation placement

This tradeoff is intentional and aligned with ANIMA’s emphasis on correctness over convenience.

---

## Enforcement

* Schema modules MUST NOT import engine services, adapters, or runtime code
* Schema validation methods SHOULD be easily testable in isolation
* Code reviews MUST reject schema validation that depends on external context

---

## Notes

This ADR does **not** mandate that all schemas implement validation — only that **if validation exists**, it must respect these constraints.
