# ADR-003: Core ↔ Module Communication Protocol, Module Types, and Lease Lifecycle

**Status:** Accepted
**Date:** 2026-01-01
**Deciders:** @RichardRosenblat
**Context:** Security, Isolation, Determinism, Observability, Future Distribution

---

## Context

ANIMA is designed as a modular system where the **Core Engine** interacts with independently developed and deployed **Modules / Capabilities**.

Modules must:

* Run in separate processes
* Be dynamically discovered
* Comply with ANIMA's strict security and isolation guarantees

Unrestricted inter-process communication mechanisms (e.g., raw sockets, REST, shared memory, shell execution) introduce unacceptable risks including privilege escalation, unclear trust boundaries, replay attacks, non-auditable behavior, and undefined failure modes.

Therefore, communication between Core and Modules must be **strictly constrained**, **cryptographically verifiable**, **auditable**, and **safe under partial failure**.
Additionally, module lifecycles must be explicitly typed and enforced to guarantee predictable execution, containment, and resource control.

---

## Decision

---

## 1. Single Communication Mechanism

**All communication between an ANIMA Core and Modules MUST occur over:**

> **gRPC over mutually authenticated TLS (mTLS) Connections**

No alternative transport, IPC mechanism, or protocol is permitted.
This requirement applies uniformly to local, remote, and distributed deployments.

---

## 2. Transport & Identity Security

* All connections MUST use TLS encryption.
* Plaintext communication is forbidden, including on `localhost`.
* Both Core and Module MUST present verifiable certificates.
* Certificates MUST encode stable identities:

  * **Core Instance URN**
  * **Module URN**

Transport authentication establishes **identity only**, never authorization.

---

## 3. Lease-Based Authorization Model

### 3.1 Lease Mental Model

A lease is understood as a:

> **Cryptographic Warrant of a Connection Between a Core and a Module, along with Allowed Actions taken through it**

A lease MUST contain:

* Connection ID (Lease ID)
* Consumer identity (Core / Core Instance URN)
* Provider identity (Module URN)
* Permitted capability methods (scope)
* Expiration time
  *(bounded by the maximum duration declared in the Module’s Capability Contract)*

---

### 3.2 Lease Authority (Critical Invariant)

> **The Core is the sole and canonical authority capable of issuing, renewing, modifying, or revoking leases.**

Modules:

* MUST NOT issue, extend, or modify leases
* MAY only acknowledge, enforce, or refuse execution based on a Core-issued lease

This removes all authorization symmetry and prevents split-brain behavior.

---

### 3.3 Lease Handshake & Establishment

1. A secure mTLS channel is established.
2. The Core initiates a handshake declaring intent and requested capabilities.
3. The Module responds with **attestation only**:
   * Identity
   * Capability contract hash
   * Declared module type
   * Maximum allowed lease duration
4. The Core validates the attestation **off-wire**.
5. If accepted, the Core issues a **signed Lease Grant**.
6. The Module acknowledges the lease and binds it to internal state.

> **A lease becomes valid only after explicit acknowledgment by the Module.**

---

### 3.4 Lease Epochs & Anti-Desynchronization

Every lease includes a **monotonic Lease Epoch**.

* Epochs start at `1` and are incremented on:

  * Renewal
  * Scope change
  * Revocation
* The Core is the sole epoch authority.

**Every request MUST carry cryptographic proof bound to:**

* Lease ID
* Lease Epoch
* Request ID / nonce

Requests with stale or mismatched epochs MUST be rejected immediately.

This prevents:

* Replay attacks
* Silent desynchronization
* Partial revocation failures

---

### 3.5 Lease Validity & Clock Discipline

* Lease expiration is evaluated using:

  * A bounded clock skew tolerance
  * Periodic Core-driven renewals
* Modules MUST treat expiration conservatively:

  * If validity is uncertain → execution is refused

There is **no implicit trust** in local wall clocks.

---

### 3.6 Lease Revocation Semantics

* Lease revocation by the Core is authoritative and final.
* Any explicit refusal to communicate by either side MUST:

  * Immediately invalidate the lease locally
  * Trigger revocation handling on the Core

There is no “half-valid” lease state.

---

### 3.7 Lease Scope Promotion & Demotion

Lease scope defines the **exact set of capability methods** a Module is authorized to execute for a given Core.
Scope is **not static**, but **scope expansion is strictly controlled**.

> **Scope may only change through an explicit Core-issued lease update.**

---

#### 3.7.1 Authority & Directionality

* Only the **Core** may grant, promote, or demote lease scope.
* Modules MUST NOT autonomously widen scope.

---
#### 3.7.2 Scope Update via Lease Epoch Bump

If the Core requires a scope change:

* A **new lease epoch** MUST be issued
* The updated scope MUST fully replace the previous scope
* The previous epoch is immediately invalid

The Core issues a signed **Lease Update** containing:

* Lease ID
* New Lease Epoch
* Full allowed scope
* Expiration time (unchanged or shortened)
* Optional execution constraints

---

#### 3.7.3 Module Enforcement Rules

Upon receiving a lease update, the Module MUST:

* Validate Core signature
* Verify epoch monotonicity
* Atomically replace its local lease context
* Reject **all requests** bearing the old epoch

If a scope promotion occurs mid-execution:

* Execution MUST continue **only if** the in-flight method remains within both:

  * Old scope
  * New scope
* Otherwise, execution MUST halt at the next interruption point

---

#### 3.7.6 Scope Demotion & Emergency Reduction

The Core MAY demote scope at any time, including:

* Security incidents
* Policy changes
* Observed misbehavior

Demotion:

* Takes effect immediately upon epoch bump
* Does not require Module acknowledgment to be enforced

---

#### 3.7.7 Security Invariants

> * A Module can never execute a capability method that was not explicitly granted in the **current lease epoch**.
> * Scope promotion is **never implicit**, **never cumulative**, and **never symmetric**.
> * Every scope change is auditable and replay-safe.

---

#### 3.7.8 Failure Semantics

If:

* A scope update is lost
* Epochs diverge
* Or validity is uncertain

Then:

> **The Module MUST fail closed and refuse execution.**

---

## 4. Capability Interface Contract

* Each Module MUST expose a strict, statically defined gRPC service interface.
* Exposed methods MUST correspond exactly to declared capability methods.
* Reflective, dynamic, or ad-hoc invocation is forbidden.
* Capability contracts MUST declare:

  * Side-effect class (pure / reversible / irreversible)
  * Abortability guarantees

---

## 5. Zero-Lease State

### 5.1 Definition

A Module is in **Zero-Lease State** when it has no currently valid lease.

This occurs on:

* Lease expiration
* Lease revocation
* Connection loss
* Failure to establish a lease within a bounded initialization window

---

### 5.2 Core Invariant

> **No Lease, No Execution**

A module with no valid lease:

* MUST reject all capability execution
* MUST NOT perform side effects
* MUST NOT process background tasks on behalf of a Core

---


## 6. Module Types & Lifecycle Semantics

Every ANIMA Module MUST declare **exactly one Module Type** in its Capability Contract.

> **A Module Type is a first-class declaration of tenancy, lifecycle authority, failure semantics, and isolation guarantees.**

The Module Type is **not an optimization hint** — it is a **hard contract** enforced by the Core, tooling, and policy.

A Module MUST be rejected if its runtime behavior contradicts its declared type.

---

### 6.1 Module Type Declaration (Normative)

Each Module Capability Contract MUST declare, at minimum:

* `module_type` 
* `tenancy_model`
* `lifecycle_authority`
* `lease_dependency`
* `state_persistence_policy`
* `side_effect_policy`

These declarations are **authoritative** and MUST be validated during handshake.

---

### 6.2 Type I — Ephemeral Private Module

#### 6.2.1 Declarative Definition

**Type I Modules are:**

* **Ephemeral**
* **Single-tenant**
* **Strictly lease-bound**
* **Core-lifecycle-controlled**

They exist *only* to serve a **single Core instance for the duration of an active lease**.

> A Type I module has no meaning outside a valid lease.

---

#### 6.2.2 Declarative Properties

| Property             | Value                            |
| -------------------- | -------------------------------- |
| Tenancy model        | Single Core                      |
| Lifecycle authority  | Core                             |
| Lease dependency     | Mandatory                        |
| Side effects         | Must be reversible or disallowed |
| Startup mode         | Core-issued only                 |

---

#### 6.2.3 Lifecycle Semantics

* The Core is the **sole authority** allowed to start the module.
* The module MUST accept leases from **exactly one Core Instance URN** defined at startup.
* Zero-Lease State inevitably leads to graceful termination after a Task Recovery Grace Period.
* Task Recovery Grace Periods:

  * MUST be bounded
  * MUST be non-renewable
  * MUST reject all non-lease traffic

> **A Type I module without a lease is considered dead, even if its process is currently still running.**

---

### 6.3 Type II — Resident Private Module

#### 6.3.1 Declarative Definition

**Type II Modules are:**

* **Resident**
* **Single-tenant**
* **Lease-gated**
* **Core-affiliated**

They are long-lived processes that serve **exactly one Core**, but whose existence is not strictly bound to lease duration.

---

#### 6.3.2 Declarative Properties

| Property             | Value                      |
| -------------------- | -------------------------- |
| Tenancy model        | Single Core                |
| Lifecycle authority  | Core or Infrastructure     |
| Lease dependency     | Mandatory for execution    |
| Side effects         | Allowed within lease scope |
| Startup mode         | Core-issued or pre-started |

---

#### 6.3.3 Lifecycle Semantics

* The module MUST bind permanently to a single Core URN.
* Zero-Lease State places the module into **Standby Mode**.
* In Standby Mode:

  * Execution is forbidden
  * Any execution is halted at the next declared interruption point, according to its abortability guarantees.
* Lease restoration and creation MUST come from the same Core.
* Any in-flight task state MAY be retained only for the duration of the Task Recovery Grace Period.


> **A Type II module without a lease is inert, not terminated.**

---

### 6.4 Type III — Resident Shared Module

#### 6.4.1 Declarative Definition

**Type III Modules are:**

* **Resident**
* **Multi-tenant**
* **Lease-partitioned**
* **Infrastructure-governed**

They are designed to safely serve **multiple independent Cores concurrently**.

> Type III is an **opt-in trust class**, not a default.

---

#### 6.4.2 Declarative Properties

| Property             | Value                 |
| -------------------- | --------------------- |
| Tenancy model        | Multi-Core            |
| Lifecycle authority  | Infrastructure        |
| Lease dependency     | Mandatory per tenant  |
| Side effects         | Lease-isolated only   |
| Startup mode         | Infrastructure-issued |

---

#### 6.4.3 Isolation & Behavior Semantics

* Each Core MUST be isolated by:

  * Lease ID
  * Core URN
* All behavior MUST be scoped to an active lease.
* Presence or behavior of one Core MUST NOT affect another.
* Task Recovery Grace Period state MUST be isolated per Lease ID and destroyed independently.

> **Any cross-tenant influence is considered a security breach. And will cause Module Blacklisting.**

Regular compliance checks and formal verification may be mandated for Type III modules by ANIMA teams in order to ensure strict adherence to isolation guarantees.

---

#### 6.4.4 Lifecycle Semantics

* Lease expiration affects only the owning Core.
* Global Zero-Lease transitions the module into Standby Mode, similar to Type II.
* Termination is controlled exclusively by infrastructure or administrators.

---

### 6.5 Invalid Configurations (Normative)

The following combinations are **invalid** and MUST be rejected:

* Any module recording persistent state for longer than a Task Recovery Grace Period
* Any module allowing side effects without lease enforcement 
* Any module executing capability logic without a lease
* Any module whose observed behavior contradicts its declared type

---

### 6.6 Design Invariant

> **Module Type is a security boundary, not an implementation detail.**

Changing a module’s type is a **breaking change** requiring:

* Capability contract update
* Policy review
* Redeployment
  
 
## 7. Type III Governance & Safety

Type III modules operate under **explicit governance** and safety requirements:

They MUST provide:

* Determinism guarantees
* Isolation self-tests
* Lease-scoped behavior enforcement
* Audit hooks

Violations result in:

* Immediate lease revocation
* Blacklisting
* Mandatory redeployment or sandboxing

Third-party modules MUST pass formal compliance checks or run in ANIMA-provided sandboxes.

---

## 8. State Persistence & Task Recovery Grace Periods

Statelessness in ANIMA means the absence of durable, cross-lease or cross-restart state.
It does not prohibit transient side effects that are fully attributable to a single lease and explicitly declared in the capability contract.

ANIMA Modules must be architecturally stateless.
All observable behavior must be attributable to explicit inputs, an active lease, and deterministic computation. State retained during the Task Recovery Grace Period MUST NOT trigger new execution or side effects.

All modules MUST be designed with no state persistence beyond the following:
* In-memory state during active tasks
* Ephemeral storage scoped to active leases
* Initialization heavy read-only resources loaded at startup, such resources MUST be deterministic, immutable, and identical across restarts.
* Caches must be:
  * scoped to a single task execution, or
  * scoped to a single active lease and destroyed on lease expiration.

Persistent state storage across restarts or lease cycles is forbidden.

Task Recovery Grace Periods MUST be:
* A bounded interval during which in-flight task state may be retained solely to support rollback, retry, or error reporting for a single lease.
* Non-renewable and non-extendable.
* Non-accessible for new leases or tasks.

---
## 9. Observability & Side-Channel Safety

* Observability is mandatory but **lease-scoped**.
* Traces, metrics, and logs MUST:

  * Never expose cross-tenant timing correlations
  * Be isolated per Core / Lease
* Shared modules MUST redact tenant-identifying metadata.

Observability MUST NOT become an information channel.

---

## Consequences

### Positive

* Single-source authorization truth
* Replay-safe, deterministic execution
* Explicit containment boundaries
* Strong multi-tenant isolation
* Failure-safe by default

### Negative

* Increased implementation rigor
* Higher compliance burden for shared modules

---

## Summary


> **ANIMA Modules are Ephemeral Private (Type I), Resident Private (Type II), or Resident Shared (Type III).**
> **All execution is gated by Core-issued cryptographic leases over mTLS.**
> **Without a valid lease, a module is inert or dead. There are no exceptions.**
> **Scope changes are explicit, auditable, and unidirectional.**
> **Module types define strict lifecycle and tenancy semantics.**
> **State persistence is forbidden beyond bounded Task Recovery Grace Periods.**
