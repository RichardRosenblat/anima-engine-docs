# ADR-000X: Core â†” Module Communication Protocol

**Status:** Accepted
**Date:** 2026-01-01
**Deciders:** @Richard Rosenblat
**Context:** Security, Isolation, Determinism, Observability, Future Distribution

---

## Context

ANIMA is designed as a modular system where the **Core Engine** interacts with independently developed and deployed **Modules / Capabilities**.

These modules may:

* run in separate processes
* run on separate machines
* be dynamically discovered
* be started or stopped by the engine
* require strict security guarantees

Unrestricted inter-process communication mechanisms (e.g. raw sockets, REST, shared memory, shell execution, dynamic imports) introduce unacceptable risks:

* privilege escalation
* command injection
* undefined trust boundaries
* environment-specific coupling

Therefore, communication between Core and Modules must be **strictly constrained**, **auditable**, and **uniform**.

---

## Decision

### 1. Single Communication Mechanism

**All communication between ANIMA Core and Modules MUST occur over:**

> **gRPC over mTLS connections.**

No alternative protocols are permitted.

This includes:

* local modules
* remote modules
* embedded modules
* future distributed or clustered deployments

---

### 2. Transport Security

* All connections MUST be encrypted using TLS.
* Plaintext communication is forbidden, even on `localhost`.
* Certificate-based authentication MUST be supported.
* Time-bound lease credentials MUST be layered on top of TLS.

---

### 3. Authentication & Authorization Model

* Modules do **not** authenticate via static secrets.
* All authorization is granted via **time-bound leases** issued by the Core.
* A lease defines:
  * scope (which capability / methods)
  * duration
  * revocation conditions
* Expired or revoked leases MUST immediately invalidate access.

This ensures:

* least privilege
* revocability
* resistance to long-lived compromise

---

### 4. Capability Interface Contract

* Each Module exposes a **strict gRPC service interface**.
* Methods exposed MUST correspond to declared capability methods.
* Method names and semantics MUST match the capability declaration.
* Undeclared methods MUST NOT be callable.

The Core interacts only with:

* the declared interface
* the declared capability metadata
* the issued lease

No reflective or dynamic invocation is allowed.

---

### 5. Lease Expiry Enforcement

* Modules MUST continuously enforce the validity of their issued leases.
* If **all active leases expire or are revoked**, and **no other valid lease is currently held**, the Module MUST:

  * immediately cease accepting requests
  * gracefully terminate its own process

* Modules MUST NOT continue running in an idle, dormant, or partially functional state after lease expiration.
* Modules MUST NOT assume that the Core will explicitly terminate them.

This guarantees that:

* orphaned modules cannot persist indefinitely
* compromised or disconnected modules self-neutralize
* resource usage remains bounded and predictable

---

### 6. Discovery & Connection Model

Modules may be:

* already running and listening
* started by the Core using engine-controlled logic
* remotely registered

Regardless of origin:

* the Core establishes the mTLS gRPC connection
* validates identity
* issues a lease
* enforces permissions

Modules never self-register trust.

---

### 7. Observability & Control

Using gRPC enables:

* structured schemas
* explicit method boundaries
* request/response tracing
* backpressure
* streaming where required (e.g. voice, presence)

This is a **feature**, not an implementation detail.

### 8. Multi-Instance & Shared-Execution Safety

Some Modules may be designed to serve **multiple Core instances** concurrently.

In such cases:

* Multi-instance Modules MUST be **explicitly declared** as such.
* Multi-instance Modules MUST implement strict isolation guarantees to prevent:
  * cross-instance data leakage
  * shared mutable state contamination
  * side-channel exposure between instances

If a Module:

* stores instance-scoped data
* retains memory across requests
* persists state outside of explicitly scoped storage

then it WILL be considered **compromised**, Anima instances may refuse to connect to it.

Additional requirements:

* Multi-instance Modules MUST be:
  * **idempotent**
  * **deterministic** for the same inputs and lease context
* Behavior MUST NOT vary based on:
  * execution order
  * co-resident instances
  * historical request state

Modules hosted on **on-premise or third-party infrastructure** MUST:

* explicitly prove compliance with these isolation guarantees, **or**
* be hosted using **ANIMA-provided execution services**, which enforce these guarantees by construction.

Shared execution is an **opt-in trust model**, not a default.

---

## Consequences

### Positive

* Strong security boundaries
* Uniform communication model
* Easy auditing and tracing
* Clean separation of concerns
* Future-ready for distributed systems
* Prevents command-injection classes of vulnerabilities

### Negative

* Slightly higher implementation complexity
* Requires gRPC tooling in supported languages
* No ad-hoc scripting shortcuts

These tradeoffs are intentional.

---

## Non-Goals

This ADR explicitly does **not** define:

* module lifecycle policies
* deployment strategies
* container orchestration
* runtime selection logic
* lease issuance algorithms

Those are addressed in separate ADRs.

---

## Summary

> **ANIMA Core and Modules communicate exclusively via secure, lease-governed gRPC interfaces.
> No commands, no scripts, no implicit trust, no exceptions.**

This decision preserves:

* system integrity
* user safety
* long-term evolvability
* architectural clarity

