# ADR-0003: Core ↔ Module Communication Protocol, Module Types, and Lease Lifecycle

**Status:** Accepted
**Date:** 2026-01-01
**Deciders:** @Richard Rosenblat
**Context:** Security, Isolation, Determinism, Observability, Future Distribution

---

## Context

ANIMA is designed as a modular system where the **Core Engine** interacts with independently developed and deployed **Modules / Capabilities**.

Modules must:

* Run in separate processes
* Be dynamically discovered
* Comply with ANIMA's strict security and isolation guarantees

Unrestricted inter-process communication mechanisms (e.g., raw sockets, REST, shared memory, shell execution) introduce unacceptable risks (privilege escalation, undefined trust boundaries, non-auditable behavior).

Therefore, communication between Core and Modules must be **strictly constrained**, **auditable**, **uniform**, and **safe under failure**. Furthermore, the lifecycle of a module—how long it lives and who it serves—must be strictly typed to ensure predictable resource management.

---

## Decision

### 1. Single Communication Mechanism

**All communication between an ANIMA Core and Modules MUST occur over:**

> **gRPC over mTLS connections**

No alternative protocols are permitted. This requirement applies uniformly to local modules, remote modules, and distributed deployments.

---

### 2. Transport Security

* All connections MUST be encrypted using TLS.
* Plaintext communication is forbidden, including on `localhost`.
* Certificate-based authentication MUST be supported.

---

### 3. Authentication & Authorization Model

Modules MUST NOT authenticate via static secrets. Authorization is granted exclusively via **time-bound encrypted leases** issued by the connection, created and kept by both the Core and the Module at connection time and periodically renewed.

A lease can be understood as a **Cryptographic Representation of a Connection and Allowed Actions taken through it** with the following properties:
  * Connection ID (Lease ID)
  * permitted capability methods (scope)
  * consumer identity (Core Instance URN)
  * provider identity (Module URN)
  * expiration time (With max allowed duration defined by the Module's capability contract)
  * revocation conditions

Upon connection establishment, the Core issues a lease to the Module and vice versa. Both sides MUST validate the lease before processing any requests.

After the initial handshake, lease data is no longer transmitted over the wire. Instead, both sides maintain an in-memory representation of the lease context. The only lease data transmitted over the wire is a cryptographic proof (e.g., signed token) that the lease is valid and renewal tokens, promotion or demotion of scope requests.

if any of the side detects lease expiration, connection failure or revocation, it MUST immediately cease all communication with the other side for that lease.

Expired or revoked leases MUST immediately invalidate authorization and refuse further communication.
Explicit refusal of communication on one side MUST trigger immediate lease revocation on the other side.

---

### 4. Capability Interface Contract

* Each Module MUST expose a **strict gRPC service interface**.
* Exposed methods MUST correspond exactly to declared capability methods.
* The Core interacts only with the declared gRPC interface and the issued lease context.
* No reflective, dynamic, or ad-hoc invocation is permitted.

---

### 5. Zero-Lease State

Regardless of the Module Type, the following invariants apply regarding lease validity.

#### 5.1 Zero-Lease State Definition

A Module is in a **Zero-Lease State** when it has no valid lease from the Core. This can occur due to:
* Lease expiration
* Lease revocation
* Connection loss
* No Connection ever being established (e.g., during initial startup) within a defined grace period.

#### 5.2 The "No Lease, No Execution" Invariant
> **A Module with no valid lease MUST NOT perform any capability execution.**

If a lease expires or is revoked:

* **Type I (Ephemeral):** The module is effectively dead and begins graceful termination.
* **Type II & III (Resident):** The module is "functionally dead." It exists in memory but allows no operations until a new valid lease is created.


---

### 6. Module Types & Lifecycle Semantics

To ensure deterministic behavior, every ANIMA Module must be classified as one of three distinct types. This type dictates the module's relationship with the Core and its behavior upon lease expiration.

#### 6.1 Type I: Ephemeral Private Module

* **Tenancy:** Single Core (Private).
* **Lifecycle:** Dies on lease expiration.
* **Declaration:** Default behavior for all modules unless otherwise specified.

**Behavior:**

1. **Core Issued Initialization:** The Startup of the module is triggered by the Core and an initial connection is established within a defined timeout.
2. **Exclusive Access:** Accepts lease renewals from only one Core instance. Identified by the Core Instance URN.
3. **Expired Lease grace period:** The module MAY implement a short grace period (e.g., a few seconds) after lease expiration to allow for transient network issues. During this period, it may ONLY accept new lease requests from the same Core instance.
4. **Zero-Lease State:** Upon lease expiration or revocation, the module enters the **Graceful Termination Window**, where the module cleans up resources and may await lease.
5. **Termination:** Once the window expires, the module **MUST self-terminate**. It releases all resources and kills its own process. It does not wait for an external kill signal.
6. **Mid-execution Lease Expiry:** If a lease expires mid-execution, the module:
   * MUST immediately halt processing.
   * MUST NOT produce side effects.
   * MUST roll back any partial state changes if possible.
   * MUST return an error indicating lease expiration.

#### 6.2 Type II: Resident Private Module

* **Tenancy:** Single Core (Private).
* **Lifecycle:** Stays alive after lease expiration.
* **Declaration:** Must be explicitly declared in the Capability Contract and the initialization type declared as either pre-started or core-started

**Behavior:**

1. **Hybrid Issued Initialization:** The Startup of the module is either triggered by the Core or pre-started by infrastructure orchestration
2. **Exclusive Access:** Accepts connections from only one Core, identified by the Core URN. 
3. **Zero-Lease State:** Upon lease expiration, the module enters **Standby Mode**. It keeps its main process running and may retain caches or expensive initialization states (e.g., large LLM weights in VRAM). But it takes on no more requests until and halts all processes until a new valid connection is made.
4. **Standby Invariants:** While in Standby (no active lease), the module:
   * MUST reject all capability execution requests.
   * MUST NOT perform side effects.
   * MUST wait for a new connection from the *same* Core.
5. **Termination:** Terminated only by an explicit core or administrative shutdown command or infrastructure orchestration, not by lease expiry.
6. **Mid-execution Lease Expiry:** If a lease expires mid-execution, the module:
   * MUST immediately halt processing.
   * MUST NOT produce side effects.
   * MUST return an error indicating lease expiration.

#### 6.3 Type III: Resident Shared Module

* **Tenancy:** Multiple Cores (Multi-Tenant).
* **Lifecycle:** Long-lived; stays alive after lease expiration.
* **Declaration:** Must be explicitly declared in the Capability Contract.

**Behavior:**

1. **Infrastructure Issued Initialization:** The Startup of the module is managed by infrastructure orchestration and is independent of any Core connection.
1. **Shared Access:** Designed to serve multiple Core instances concurrently.
2. **Isolation:** Must implement strict logical isolation to prevent cross-instance data leakage. State must be scoped to the specific Lease ID/Core ID and deleted upon lease expiration.
3. **Zero-Lease State:**
   * The module tracks active leases per Core.
   * Lease expiration for *Core A* revokes access for *Core A* only; *Core B* continues unaffected.
   * If **all** leases expire (Global Zero-Lease), the module enters **Standby Mode** (similar to Type II).

4. **Termination:** Manually managed by infrastructure/administrators.

---


### 7. Multi-Tenant Safety (Specific to Type III)

Type III Modules operate under an **opt-in trust model**. Because they share execution environments between Cores, they are subject to higher scrutiny.

* **Idempotency:** Behavior must not vary based on the presence of other tenants.
* **Data Scoping:** Storing instance-scoped data beyond the lifetime of the lease is forbidden.
* **Contamination:** If a Type III module allows one Core's state to affect another Core's execution, it is considered compromised and will be blacklisted.

Modules hosted on third-party infrastructure must prove compliance with these isolation guarantees or use ANIMA-provided execution services (sandboxes).

---

### 8. Observability & Control

Using gRPC enables structured schemas, request tracing, backpressure, and streaming. These are architectural requirements for all three module types.

---

## Consequences

### Positive

* **Clear Resource Management:** The Core knows exactly which modules need to be restarted (Type I) and which are expensive resources to be preserved (Type II/III).
* **Strict Isolation:** Private modules (Type I & II) are guaranteed to never leak data to other Cores.
* **Efficiency:** Type III modules allow amortization of heavy resources (e.g., a single GPU inference server) across multiple Cores.
* **Safety:** The "Lease-Zero" state ensures that even "alive" modules cannot act maliciously without a valid warrant (lease).

### Negative

* **Complexity:** Implementing Type III modules requires rigorous thread-safety and state management.
* **Tooling Overhead:** Requires gRPC and TLS infrastructure for even simple local modules.

---

## Summary

> **ANIMA Modules fall into three strict categories: Ephemeral Private (Type I), Resident Private (Type II), and Resident Shared (Type III).**
> **All interaction is governed by time-bound leases over mTLS. Without a lease, a module is either dead (Type I) or frozen (Type II/III). There are no exceptions.**