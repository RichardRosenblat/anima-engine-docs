# ADR-010: Adapter–Actuator Split with Strict Process Boundary (No Third-Party Code in Core)

**Status:** Accepted  
**Date:** 2026-01-07  
**Deciders:** @RichardRosenblat  
**Context:** Security, Isolation, Hexagonal Architecture, DDD

---

## Context

ANIMA integrates external Modules to perceive inputs and execute side effects. Early designs considered loading module-owned Python into the Core for translation (“adapters”). That is a security breach: Core must never execute third-party code.

To preserve safety and hexagonal boundaries while keeping Modules practical to ship, we split module responsibilities and enforce a strict process boundary.

---

## Decision

Every Module is divided into two parts, both running out-of-process from the Core:

- Adapter — Pure translation and schema validation
- Actuator — Effectful execution that touches APIs/hardware

The Core never loads or executes module-owned code. All Core ↔ Module interaction occurs over gRPC with mTLS and Core-issued leases (ADR-003).

---

## Definitions

### Adapter (Module-side, Pure Translation)
- Input path: maps captured signals → Core input events 
- Output path: maps Core Intent (capability URN + payload) → module command schema
- Responsibilities:
  - deterministic translation
  - JSON Schema validation against the capability contract
  - lease scope enforcement on outbound calls
- Prohibitions:
  - no planning, no policy
  - no external I/O beyond gRPC to Core or local actuator invocation
  - no memory access or Core internals

### Actuator (Module-side, Effectful Execution)
- Executes real-world side effects (APIs, hardware, platforms)
- Enforces lease scope and interruption policies (ADR-005)
- Emits observability events with ADR-004 envelope
- Contains zero Core logic or reasoning

---

## Process Boundary (Invariant)

- Core runs only trusted, engine-owned code.
- Adapters and Actuators run in module-owned processes.
- All communication uses gRPC over mTLS with attested identities (Core URN, Module URN) and Core-issued leases (ADR-003).
- No dynamic imports, plugins, or Python execution from modules inside Core.

---

## NLP Ownership in Natural Language Modules

Modules that deal with natural language input and output MAY either ship an NLP implementation or delegate NLP responsibilities to the Core’s Arcuate (ADR-009). This choice must preserve process isolation and the Adapter–Actuator split.

### Natural Language Input
- Option A — Module-owned NLP:
  - The module’s Adapter performs local NLP to transform input.nl → input.semantic events.
  - Constraints:
    - Translation only; no planning or policy
    - Include confidence and provenance in semantic payloads
    - No Core memory access; provenance reflects “module”
- Option B — Delegate to Arcuate:
  - The module’s Adapter publishes input.nl events to Core.
  - The Core’s Arcuate consumes input.nl and produces input.semantic; Core reasons on semantic events.
  - Constraints:
    - Adapter remains pure; no embedded NLP
    - Process boundary preserved; no plugin code in Core

### Natural Language Output (e.g., TTS, chat delivery)
- Option A — Module-owned NLG:
  - The module’s Adapter maps Core intents to output command schemas and performs local NLG (surface realization) before Actuator execution (e.g., TTS synthesis, message send).
  - Constraints:
    - NLG is translation; no planning, no memory access
    - Observability events MUST capture intent, realization metadata, and execution outcome
- Option B — Delegate to Arcuate:
  - The Core produces the linguistic surface via Arcuate from an intent’s semantic content.
  - The module’s Adapter translates the realized text into the module’s command; the Actuator executes (e.g., speak/send).
  - Constraints:
    - Adapter stays pure; Actuator performs side effects
    - Arcuate usage follows ADR-009 isolation rules

In all cases:
- Adapters remain pure mapping + validation.
- Actuators perform IO and effects under valid leases (ADR-003).
- Semantic events MUST include confidence and provenance fields (ADR-011).
- Natural language MUST NOT trigger direct execution; the pipeline remains Input → Interpretation → Intent → Validation/Confirmation → Execution (Safety Model).

---

## Protocol & Contracts

- Inbound (Module → Core): Adapter publishes input events and event types.
- Outbound (Core → Module): Core calls Adapter via a generic Capability Gateway:
  - capability_urn + schema_version + payload (validated by adapter)
  - LeaseMeta (lease_id, epoch) and ExecMeta (execution/trace/span)
- Capability Contract:
  - declarative JSON Schemas for command payloads
  - method side-effect class (reversible/irreversible)
  - interruption policy (soft-stop/hard-stop/checkpoint/non-interruptible)
  - maximum lease duration

---

## Security Invariants

- No plugin code in Core — ever.
- All module execution requires a valid lease with current epoch (ADR-003).
- Scope promotion/demotion occurs only via Core-issued lease updates.
- Zero-Lease State: modules are inert (Type II standby or Type I terminate).
- Adapters cannot widen scope or bypass Core gating.

---

## Observability

- Adapters and Actuators emit structured events per ADR-004:
  - execution_id, trace_id, span_id, thread_id, timestamp
  - instance_urn, core_urn
  - source=module:<name> and type=
  - payload=structured fields only
- No free-text logging as authority; events are the source of truth.

---

## Packaging Pattern (Module-Owned, Layered Cleanly)

A module may ship Adapter and Actuator together while preserving purity:

- adapter/
  - input/  (signals → input.* events; pure mapping)
  - output/ (intent → commands; pure mapping + schema validation)
- actuator/ (effectful execution: APIs/hardware)
- capability_contract/ (JSON Schemas + manifest)
- transport/ (gRPC server/client; mTLS; lease enforcement)
- proto/ (IDL for CapabilityGateway and Adapter services)

---

## Consequences

### Positive
- Eliminates code injection risk in Core
- Preserves hexagonal boundaries and testability
- Clear responsibility split (translate vs execute)
- Strong auditability via structured events

### Trade-offs
- Requires strict schema discipline and manifest validation
- Slightly more wiring (gRPC + lease lifecycle)

---

## Related ADRs

- ADR-003 — Core ↔ Module protocol, module types, leases
- ADR-004 — Observability model and event envelope
- ADR-005 — Interruption & preemption model
- ADR-007 — Infrastructure & adapter rules
- ADR-011 — Event-based input architecture

---

## Final Statement

Core reasons and supervises. Modules adapt and act.  
No third-party code runs inside Core.