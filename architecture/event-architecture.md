# Event Architecture — Observability and Input System

**Related ADRs:**
* [ADR-004: Observability, Event Logging, and Execution Traceability](../adr/ADR-004.md)
* [ADR-011: Event-Based Input Architecture with Natural Language, System, and Semantic Events](../adr/ADR-011.md)

---

## Overview

ANIMA uses a unified **event-based architecture** for both observability and input processing. This ensures:

* Structured, auditable data
* Execution-scoped isolation
* Causal traceability
* Concurrency safety
* Replayability

---

## Event-Based Observability Model

### Events vs. Logs

ANIMA does **not** produce traditional log lines.

Instead, **all observability output is expressed as structured events**.

An event represents a **fact** that occurred in the system.

Events are:

* Immutable
* Append-only
* Timestamped
* Causally linked
* Execution-scoped

---

## Execution as the Primary Partition Boundary

All observability data MUST be partitioned by **execution**.

An **execution** is defined as:

* A bounded Core runtime
* A single causal universe
* The highest-level isolation boundary for observability

Each execution is assigned a globally unique:

```
execution_id
```

This ID:

* Is generated by the Core at startup (or explicit run creation)
* Is attached to **every event**
* Is propagated to **all Modules**
* Is included in lease contexts

Time alone MUST NOT be used as the primary partition key.

---

## File-Based Event Sinks (Initial Implementation)

For initial development and local execution, ANIMA uses **file-based sinks**.

File layout is **execution-partitioned**:

```text
events/
  executions/
    exec-<uuid>/
      metadata.json
      events.ndjson
```

Where:

* `metadata.json` describes the execution context
* `events.ndjson` is an append-only newline-delimited JSON event stream

---

## Execution Metadata

Each execution directory MUST contain metadata describing the execution.

Example:

```json
{
  "execution_id": "exec-9f3c2a7e",
  "started_at": "2026-01-01T18:04:12Z",
  "ended_at": null,
  "core_version": "0.4.0",
  "host": "anima-core-01"
}
```

---

## Event Structure (Required Fields)

Every event MUST include at minimum:

```json
{
  "execution_id": "exec-uuid",
  "trace_id": "trace-uuid",
  "span_id": "span-uuid",
  "parent_span_id": null,
  "thread_id": "ctx-identifier",
  "timestamp": "RFC3339",
  "source": "core | module:<name>",
  "type": "event.type.identifier",
  "payload": {}
}
```

### Semantic Responsibilities

* **execution_id** → execution isolation
* **trace_id** → end-to-end causal chain
* **span_id / parent_span_id** → hierarchical structure
* **thread_id** → concurrency visibility
* **type** → semantic meaning (stable, documented)
* **payload** → structured data only (no free text)

---

## Concurrency & Multithreading Guarantees

Observability MUST support concurrent execution.

This is achieved by:

* Execution-level file isolation
* Append-only writes
* Thread-level identifiers in events

There is **no requirement** for total ordering across threads. Ordering is derived from:

* Trace relationships
* Span hierarchies
* Timestamps as secondary context

---

## Event-Based Input Architecture

### Core Principle

The ANIMA Core consumes only **structured input events**, never raw signals.

All inputs—human, system, or environmental—MUST be transformed into events by modules (via their Adapter) before reaching the Core.

---

## Canonical Event Categories

### 1. Natural Language (input.nl; Pre-Semantic)

Represents raw linguistic content after capture/transcription, without interpretation.

Characteristics:

* No intent
* No assumptions
* Low trust
* provenance="observed"

Example:

```json
{
  "execution_id": "exec-123",
  "trace_id": "trace-aaa",
  "span_id": "span-001",
  "parent_span_id": null,
  "thread_id": "input-mic-1",
  "timestamp": "2026-01-07T12:34:56Z",
  "source": "module:microphone",
  "type": "input.nl",
  "payload": {
    "text": "send this file to discord",
    "language": "en-US",
    "confidence": 0.93,
    "provenance": "observed"
  }
}
```

---

### 2. System / Mechanical (input.system; Non-Natural-Language)

Represents observable facts or state changes, not language.

Characteristics:

* Deterministic facts
* High trust
* No linguistic interpretation required

Example:

```json
{
  "execution_id": "exec-123",
  "trace_id": "trace-bbb",
  "span_id": "span-010",
  "parent_span_id": null,
  "thread_id": "input-vscode",
  "timestamp": "2026-01-07T12:35:10Z",
  "source": "module:vscode",
  "type": "input.system",
  "payload": {
    "action": "file_opened",
    "path": "/project/main.py"
  }
}
```

---

### 3. Semantic (input.semantic; Post-Interpretation)

Represents asserted meaning extracted by an NLP layer of an NLP-capable module or the optional Arcuate.

Characteristics:

* Explicit intent + confidence + provenance
* Core reasons directly on these
* Bypasses further linguistic processing

Example:

```json
{
  "execution_id": "exec-123",
  "trace_id": "trace-ccc",
  "span_id": "span-020",
  "parent_span_id": null,
  "thread_id": "nlp-arcuate",
  "timestamp": "2026-01-07T12:35:20Z",
  "source": "adapter:arcuate",
  "type": "input.semantic",
  "payload": {
    "intent": "send_message",
    "target": "discord",
    "content_ref": "file://active",
    "confidence": 0.88,
    "provenance": "arcuate"
  }
}
```

---

## Interruptions as Events

Interruptions enter as input events (see [ADR-005: Interruption & Preemption Model](../adr/ADR-005.md)):

```json
{
  "type": "input.semantic",
  "payload": {
    "intent": "interrupt",
    "target": "speech_output",
    "urgency": "high",
    "confidence": 0.95,
    "provenance": "arcuate|module"
  }
}
```

This enables consistent classification (override/cancel/queue/clarification/emergency), policy enforcement, and traceability.

---

## Module Participation

All Modules MUST:

* Emit events using the same schema
* Include execution_id propagated from the Core
* Respect trace and span context provided by the Core
* Never emit events outside an execution context

Modules MUST NOT:

* Write directly to Core files
* Invent execution IDs
* Mix data from multiple executions

---

## Future Extensions

This architecture intentionally allows future sinks, including:

* Centralized event stores
* Streaming pipelines
* Observability backends
* Distributed trace systems

All future implementations MUST preserve:

* Execution partitioning
* Immutable event semantics
* Causal traceability

---

## Benefits

* Clear execution isolation
* Deterministic replayability
* Safe concurrency
* Audit-grade observability
* Strong foundation for tooling
* No log interleaving ambiguity
* Strong decoupling between Core and modules
* Clear trust boundaries
* Natural interruption handling

---

## Summary

> **ANIMA does not log text. ANIMA records facts.**
>
> Observability is:
>
> * structured
> * execution-scoped
> * causally traceable
> * concurrency-safe
>
> Execution is the fundamental boundary.
> Events are the source of truth.

> **ANIMA is an event-reasoning engine.**
> **Meaning enters the Core already shaped as input events.**
> **Adapters standardize, the kernel supervises, and the Core reasons.**
