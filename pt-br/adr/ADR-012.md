# ADR-012: Limites de Roteamento do Core — Gateways, Registro de Capacidades, Autoridade de Leases e Orquestração de Tarefas

**Status:** Rascunho  
**Date:** 2026-01-08  
**Deciders:** @RichardRosenblat  
**Context:** limites do Core, supervisão do kernel, execução de módulos, autoridade de leases, estabilização de terminologia

---

## Contexto

À medida que a arquitetura do ANIMA amadureceu, várias discussões convergiram para um padrão estrutural recorrente:

- O Core (Cognitive Kernel) deve **supervisionar** trabalho, não executá-lo (ADR-008).
- O Core nunca deve executar código de terceiros; Módulos rodam fora do processo (ADR-010).
- Toda execução Core ↔ Módulo é controlada por leases e segura por época (epoch-safe) (ADR-003).
- Entradas e observabilidade são baseadas em eventos e escopadas por execução (ADR-004, ADR-011).
- Cortex é obrigatório e Arcuate é opcional; Arcuate é apenas tradutor (ADR-009).

Porém, o código e as discussões de design correm risco de ambiguidade em termos como:

- “Gateway” (às vezes usado como “host de lógica de domínio”)
- “ModuleRegistry” (às vezes absorvendo regras de autorização)
- “TaskOrchestrator” (às vezes absorvendo política de domínio)

Este ADR estabiliza terminologia e limites para que:

- o ANIMA permaneça um sistema limpo hexagonal/DDD
- a autorização permaneça inequívoca
- e o kernel não acumule lógica de negócio escondida

---

## Decisão

O ANIMA adota formalmente os seguintes contratos de limite (boundary contracts):

1. **Gateways do Core são limites de roteamento com um único ponto de entrada `send()`.**
   - Um Gateway despacha objetos de operação tipados para uma implementação de porta/cliente injetada.
   - Um Gateway não contém **política de domínio** e não realiza **I/O externo**.
   - A “implementação por trás do Gateway” DEVE ser tratada como **Porta/Cliente** (porta hexagonal), e não como um bounded context de domínio.

2. **TaskOrchestrator é a espinha dorsal de execução supervisionada do Kernel, não um motor de política de execução.**
   - TaskOrchestrator gerencia ciclo de vida (spawn/run/pause/cancel/complete), cooperação de interrupções e agregação de resultados.
   - Políticas de domínio/aplicação (ex.: “regras de retry porque essa classe de intent é importante”) NÃO DEVEM viver no TaskOrchestrator.
   - Decisões de política devem viver em componentes explícitos de política na camada de domínio/aplicação apropriada e serem injetadas.

3. **ModuleRegistry é autoridade de descoberta de capacidades e de conexão, não autoridade de autorização.**
   - ModuleRegistry descobre módulos, realiza handshake/attestation, rastreia liveness e fornece lookup em runtime de endpoints de capacidades.
   - ModuleRegistry NÃO DEVE decidir se uma capacidade é *permitida* para executar (isso pertence a leases + política de segurança).

4. **A autoridade de Lease é explícita e pertence ao Core.**
   - Emissão/renovação/revogação/atualização de escopo/autoridade de epoch DEVE permanecer como um conceito dedicado do Core (“LeaseManager”).
   - Nenhum outro componente (Registry, Port, Module) pode se tornar a autoridade implícita de leases.
   - Isso reforça estruturalmente o ADR-003.

5. **Ports de módulo são sessões vinculadas a lease, não definições de comportamento.**
   - Um ModulePort/Session representa uma conexão de transporte opaca vinculada a:
     - `LeaseMeta` (lease_id, epoch, proofs)
     - `ExecMeta` (execution_id, trace_id, span_id, thread_id)
   - Ele serializa requisições, anexa lease meta + exec meta e lida com falhas de transporte.
   - Ele não codifica semântica de negócio sobre *o que* fazer ou *por que*.

6. **Fluxo event-first do kernel é canônico.**
   - O kernel consome eventos estruturados via a fila unificada de eventos (ADR-011).
   - Transições de planejamento e execução DEVEM emitir eventos estruturados (ADR-004).
   - “Fluxos de chamada direta” são permitidos internamente por conveniência de implementação, mas devem preservar o modelo conceitual:
     evento → raciocinar → intent → validar → agendar → invocar → observar.

---

## Definições

### 1) Gateway

Um Gateway do Core é um limite de roteamento que possui uma implementação de porta/cliente e expõe um único ponto de entrada:

- `send(operation) -> result`

Responsabilidades:
- aceitar objetos de operação
- despachar por tipo de operação
- aplicar restrições de limite (tipagem, ops permitidas, regras “translator-only”, etc.)
- encaminhar para uma implementação de porta/cliente injetada

Não-responsabilidades:
- nenhuma política de domínio (sem “devemos fazer X?”)
- nenhum I/O de infraestrutura

**Nota:** A implementação por trás do Gateway DEVE ser nomeada como `CortexPort`, `MemoryPort`, `ArcuateClient`, etc., para reduzir confusão com bounded contexts.

---

### 2) CortexGateway / MTLGateway / ArcuateGateway

- **CortexGateway** roteia operações cognitivas para o Cortex (obrigatório) via porta/cliente (ADR-009).
- **MTLGateway** roteia operações de memória para portas MTL (repositórios, serviços de memória) sem embutir política de memória.
- **ArcuateGateway** roteia operações de tradução NLP para o Arcuate (se presente) e DEVE permanecer translator-only (ADR-009).

---

### 3) Objetos de Operação

Gateways operam sobre objetos de operação tipados. Ops representam “qual comportamento” sem codificar como o roteamento acontece.

Categorias de exemplo:
- `ProcessEvent`
- `EvaluateIntent`
- `Reflect`
- `TranslateInputNlToSemantic`
- `RealizeIntentToNl`

---

### 4) ModuleRegistry

ModuleRegistry é a autoridade para:
- discovery
- rastreamento de attestation/handshake
- rastreamento de liveness
- indexação de capacidades
- retornar um handle de endpoint vivo para uma capacidade

Não é a autoridade para:
- permissionamento
- concessão de leases
- promoção/demissão de escopo

---

### 5) LeaseManager (Pertence ao Core)

LeaseManager é um componente dedicado do Core responsável por:
- emitir leases
- renovar leases
- revogar leases
- gerenciar epochs
- reforçar a semântica “sem lease, sem execução” (ADR-003)

LeaseManager é o único componente autorizado a mutar estado de lease.

---

### 6) ModulePort / ModuleSession

Um ModulePort/Session representa:
- uma conexão de transporte vinculada a:
  - `LeaseMeta` (lease_id, epoch)
  - `ExecMeta` (contexto de execução/trace/span)
- uma superfície opaca de invocação:
  - `invoke(capability_urn, payload, meta) -> result`

Responsabilidades:
- serialização/deserialização
- anexar metadados obrigatórios
- retries para falha de transporte (se configurado)
- expor erros de forma determinística

Não-responsabilidades:
- decidir semântica de negócio
- decidir autorização
- decidir políticas como “quantos retries porque é importante”

---

### 7) TaskOrchestrator

TaskOrchestrator é a espinha dorsal de execução supervisionada do Kernel.

Responsabilidades:
- gerenciar ciclo de vida de tarefas/spans (spawn/run/pause/cancel/complete) (ADR-008)
- cooperar com roteamento e políticas de interrupção (ADR-005)
- resolver capacidades via ModuleRegistry
- obter/validar contexto de lease via LeaseManager antes de invocar (ADR-003)
- despachar tarefas para ModulePorts
- agregar resultados e emitir eventos (ADR-004)

Não-responsabilidades:
- codificar política de domínio (ex.: retry específico por significado de intent)
- embutir lógica de planejamento (isso pertence à cognição/Cortex)
- burlar a autoridade de lease

---

## Fluxo Conceitual Canônico

```text
Evento de Entrada
  ↓ (fila de eventos; ADR-011)
Core consome evento
  ↓
CortexGateway.send(ProcessEvent(event))
  ↓
Grafo de Intents
  ↓ (decisões de segurança / permissão / lease)
TaskOrchestrator agenda trabalho
  ↓
ModuleRegistry resolve capacidade → ModulePort/Session
  ↓
LeaseManager garante lease válido + epoch
  ↓
ModulePort.invoke(capability_urn, payload, exec_meta, lease_meta)
  ↓
Module Adapter → Module Actuator
  ↓
Efeitos no mundo + eventos estruturados (ADR-004)
```

---

## Consequências

### Positivas

- Evita “policy creep” escondido em componentes de roteamento e agendamento do Core
- Torna a autoridade de leases explícita e auditável (reforça ADR-003)
- Estabiliza terminologia para que “Gateway/Registry/Orchestrator” não derive
- Preserva limites hexagonais: portas em domínios, adapters em infra/runtime
- Torna migração de IPC (in-process agora, gRPC depois) consistente

### Trade-offs

- Mais componentes explícitos (LeaseManager, injeção de política) vs. “colocar no orchestrator”
- Um pouco mais de wiring no runtime/composition root
- Exige disciplina em naming (“Port/Client” vs “Implementation”) para evitar deriva conceitual

---

## ADRs Relacionados

- ADR-003 — Protocolo Core ↔ Module, tipos de módulo, leases
- ADR-004 — Modelo de observabilidade e envelope de eventos
- ADR-005 — Modelo de interrupção & preempção
- ADR-008 — Core como cognitive kernel (supervisiona, não executa)
- ADR-009 — Cortex obrigatório, Arcuate opcional + restrição translator-only
- ADR-010 — Adapter–Actuator split; sem código de terceiros no Core
- ADR-011 — Arquitetura de input baseada em eventos

---

## Declaração Final

Gateways roteiam.  
Registry descobre.  
LeaseManager autoriza.  
TaskOrchestrator supervisiona a execução.  
Cortex decide.

Esta separação é obrigatória para preservar o modelo de kernel do ANIMA, invariantes de segurança e manutenção de longo prazo.