# ADR-007: Infrastructure Layer & Adapter Rules

**Status:** Accepted
**Date:** 2026-01-04
**Deciders:** @Richard Rosenblat
**Context:** Hexagonal Architecture, DDD, Runtime Composition

---

## Context

ANIMA follows **Hexagonal Architecture** and **Domain-Driven Design (DDD)**. As the system grows, a clear and enforceable boundary is required between:

* **Domain logic** (meaning, rules, invariants)
* **Infrastructure concerns** (IO, databases, external systems)

Without strict rules, infrastructure code tends to:

* Leak into domains
* Encode business logic implicitly
* Become an unstructured collection of implementations

This ADR defines:

* Why the `infra/` folder exists
* What is allowed inside it
* How it is structured
* How it connects to domains and runtime

---

## Core Principle

> **Domains must never talk directly to the outside world.**

The outside world includes:

* Databases (Postgres, SQLite, Redis)
* File systems
* Network services
* Message brokers
* OS time, environment, entropy

Domains express their needs through **interfaces (ports)**.
Infrastructure fulfills those needs through **adapters**.

---

## Why the `infra/` Folder Exists

The `infra/` folder exists to:

* Isolate all IO and external system interaction
* Implement domain-defined interfaces (ports)
* Allow replacement of technologies without touching domains
* Keep domain logic pure, testable, and stable

Infrastructure is **not** part of the domain model.

---

## Domain ↔ Infrastructure Relationship

### Dependency Direction (Non-Negotiable)

```
infra  ─────▶  domains
runtime ────▶  infra + domains

domains ─╳──▶  infra
```

Rules:

* Domains **define ports** (interfaces / abstractions)
* Infra **implements ports**
* Domains **never import infra**
* Runtime is the only layer allowed to import and wire everything

---

## Domain Ports (Interfaces)

Domains define **ports** for anything that is external or variable.

Examples:

* Repositories
* Event buses
* Clocks
* File stores
* Message dispatchers

```python
# domains/orders/ports.py
from typing import Protocol

class OrderRepository(Protocol):
    def save(self, order: Order) -> None: ...
```

Domains depend **only** on these abstractions.

---

## Infrastructure Adapters

Infrastructure adapters:

* Implement exactly one domain port
* Contain zero business logic
* Translate between domain concepts and external systems

```python
# infra/persistence/postgres/order_repository.py
from domains.orders.ports import OrderRepository

class PostgresOrderRepository(OrderRepository):
    def save(self, order: Order) -> None:
        ...
```

---

## Infra Folder Structure

Infrastructure is structured by **technology**, then by **adapter responsibility**.

```
/infra
  __main__.py
  /persistence
    /postgres
      __main__.py
      order_repository.py
      user_repository.py
      memory_repository.py

    /sqlite
      __main__.py
      order_repository.py

  /messaging
    /kafka
      __main__.py
      domain_event_bus.py

  /clock
      __main__.py
    system_clock.py
```

### Structure Rules

1. One adapter per file
2. Each adapter implements exactly one domain port
3. No domain logic in infra
4. No cross-adapter imports
5. No domain-to-infra imports

---

## Infra Internal Helpers

Infra may contain **private helpers** for shared technical concerns.

```
infra/persistence/postgres/
  __main__.py
  _connection.py
  _base_repo.py
  order_repository.py
```

Rules:

* Helpers are prefixed with `_`
* Helpers are not ports
* Helpers are not visible to domains

---

## Runtime Responsibilities

Runtime is the **composition root**.

Runtime:

* Selects infrastructure implementations
* Instantiates adapters
* Injects them into domains

```python
repo = PostgresOrderRepository(pool)
service = OrderService(repo)
```

Domains must never perform wiring or instantiation of infra.

---

## Forbidden Practices

❌ Domains importing infra implementations
❌ Infra defining business rules
❌ Infra selecting implementations
❌ Implicit interface matching ("same method names")
❌ Large multi-domain adapter files

---

## Consequences

**Positive:**

* Clean dependency graph
* Replaceable infrastructure
* High testability
* Long-term architectural stability

**Negative:**

* More files
* More explicit wiring
* Higher upfront discipline

These trade-offs are intentional.

---

## Final Principle

> **Domains describe reality.
> Infrastructure connects reality to the outside world.
> Runtime assembles the system.**
