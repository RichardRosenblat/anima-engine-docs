# ADR-004: Observability, Event Logging, and Execution Traceability

**Status:** Accepted  
**Date:** 2026-01-03  
**Deciders:** @RichardRosenblat  
**Context:** Observability, Debuggability, Determinism, Concurrency, Auditability, Future Distribution  

---

## Context

ANIMA is a highly modular, concurrent system composed of:

* a reasoning Core
* multiple independently executing Modules
* asynchronous capability invocations
* concurrent execution threads
* time-bound leases and security decisions

Traditional logging approaches based on:

* unstructured text lines
* global log files
* time-only ordering

are insufficient and actively harmful in this context.

They fail to provide:

* causal relationships
* execution boundaries
* concurrency clarity
* replayability
* audit-grade traceability

ANIMA requires observability that reflects **what actually happens**, not just *when* something printed text.

---

## Problem Statement

The system must support:

* multiple concurrent executions
* parallel reasoning threads
* distributed modules
* future clustering
* security auditing
* human-readable debugging
* machine-readable analysis

Without strict structure and isolation, observability data becomes:

* ambiguous
* unsafe to interpret
* difficult to correlate
* impossible to replay reliably

---

## Decision

### 1. Event-Based Observability Model

ANIMA does **not** produce traditional log lines.

Instead, **all observability output is expressed as structured events**.

An event represents a **fact** that occurred in the system.

Events are:

* immutable
* append-only
* timestamped
* causally linked
* execution-scoped

---

### 2. Execution as the Primary Partition Boundary

All observability data MUST be partitioned by **execution**.

An **execution** is defined as:

* a bounded Core runtime
* a single causal universe
* the highest-level isolation boundary for observability

Each execution is assigned a globally unique:

```
execution_id
```

This ID:

* is generated by the Core at startup (or explicit run creation)
* is attached to **every event**
* is propagated to **all Modules**
* is included in lease contexts

Time alone MUST NOT be used as the primary partition key.

---

### 3. File-Based Event Sinks (Initial Implementation)

For initial development and local execution, ANIMA uses **file-based sinks**.

File layout is **execution-partitioned**:

```text
events/
  executions/
    exec-<uuid>/
      metadata.json
      events.ndjson
```

Where:

* `metadata.json` describes the execution context
* `events.ndjson` is an append-only newline-delimited JSON event stream

---

### 4. Execution Metadata

Each execution directory MUST contain metadata describing the execution.

Example:

```json
{
  "execution_id": "exec-9f3c2a7e",
  "started_at": "2026-01-01T18:04:12Z",
  "ended_at": null,
  "core_version": "0.4.0",
  "host": "anima-core-01"
}
```

This metadata provides:

* human context
* audit traceability
* replay anchoring

---

### 5. Event Structure (Required Fields)

Every event MUST include at minimum:

```json
{
  "execution_id": "exec-uuid",
  "trace_id": "trace-uuid",
  "span_id": "span-uuid",
  "parent_span_id": null,
  "thread_id": "ctx-identifier",
  "timestamp": "RFC3339",
  "source": "core | module:<name>",
  "type": "event.type.identifier",
  "payload": {}
}
```

#### Semantic responsibilities:

* **execution_id** → execution isolation
* **trace_id** → end-to-end causal chain
* **span_id / parent_span_id** → hierarchical structure
* **thread_id** → concurrency visibility
* **type** → semantic meaning (stable, documented)
* **payload** → structured data only (no free text)

---

### 6. Concurrency & Multithreading Guarantees

Observability MUST support concurrent execution.

This is achieved by:

* execution-level file isolation
* append-only writes
* thread-level identifiers in events

There is **no requirement** for total ordering across threads.
Ordering is derived from:

* trace relationships
* span hierarchies
* timestamps as secondary context

---

### 7. Human Readability & Timeline Visualization

Although events are machine-readable JSON, the model is designed to support:

* timeline visualizers
* filtered views (by trace, thread, module)
* collapsible span trees
* replay tooling

Human readability is achieved through:

* structured schemas
* stable event types
* deterministic fields
* tooling (not ad-hoc text)

Raw files are not intended to be read directly.

---

### 8. Module Participation

All Modules MUST:

* emit events using the same schema
* include execution_id propagated from the Core
* respect trace and span context provided by the Core
* never emit events outside an execution context

Modules MUST NOT:

* write directly to Core files
* invent execution IDs
* mix data from multiple executions

---

### 9. Future Extensions

This ADR intentionally allows future sinks, including:

* centralized event stores
* streaming pipelines
* observability backends
* distributed trace systems

All future implementations MUST preserve:

* execution partitioning
* immutable event semantics
* causal traceability

---

## Consequences

### Positive

* Clear execution isolation
* Deterministic replayability
* Safe concurrency
* Audit-grade observability
* Strong foundation for tooling
* No log interleaving ambiguity

### Negative

* Requires upfront schema discipline
* Tooling needed for visualization
* Less immediate “print debugging”

These tradeoffs are intentional and aligned with ANIMA’s goals.

---

## Non-Goals

This ADR does **not** define:

* real-time dashboards
* alerting systems
* log aggregation infrastructure
* long-term storage policies
* visualization tooling UX

These are addressed separately.

---

## Summary

> **ANIMA does not log text.
> ANIMA records facts.**
>
> Observability is:
>
> * structured
> * execution-scoped
> * causally traceable
> * concurrency-safe
>
> Execution is the fundamental boundary.
> Events are the source of truth.
