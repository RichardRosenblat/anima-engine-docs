# ADR-003: Protocolo de Comunicação Core ↔ Module, Tipos de Módulos e Ciclo de Vida de Leases

**Status:** Aceito  
**Data:** 2026-01-01  
**Decisores:** @RichardRosenblat  
**Contexto:** Segurança, Isolamento, Determinismo, Observabilidade, Distribuição Futura  

---

## Contexto

ANIMA é projetado como um sistema modular onde o **Core Engine** interage com **Módulos / Capacidades** desenvolvidos e implantados independentemente.

Os módulos devem:

* Executar em processos separados
* Ser descobertos dinamicamente
* Cumprir as garantias rigorosas de segurança e isolamento do ANIMA

Mecanismos irrestritos de comunicação entre processos (por exemplo, sockets brutos, REST, memória compartilhada, execução de shell) introduzem riscos inaceitáveis, incluindo escalação de privilégios, limites de confiança indefinidos, ataques de repetição, comportamento não auditável e modos de falha indefinidos.

Portanto, a comunicação entre Core e Módulos deve ser **estritamente restrita**, **criptograficamente verificável**, **auditável** e **segura sob falha parcial**.
Além disso, os ciclos de vida dos módulos devem ser explicitamente tipados e aplicados para garantir execução previsível, contenção e controle de recursos.

---

## Decisão

---

## 1. Mecanismo Único de Comunicação

**Toda comunicação entre um ANIMA Core e Módulos DEVE ocorrer através de:**

> **gRPC sobre Conexões TLS mutuamente autenticadas (mTLS)**

Nenhum transporte alternativo, mecanismo IPC ou protocolo é permitido.
Este requisito se aplica uniformemente a implantações locais, remotas e distribuídas.

---

## 2. Segurança de Transporte e Identidade

* Todas as conexões DEVEM usar criptografia TLS.
* Comunicação em texto simples é proibida, inclusive em `localhost`.
* Tanto o Core quanto o Módulo DEVEM apresentar certificados verificáveis.
* Os certificados DEVEM codificar identidades estáveis:

  * **URN da Instância do Core**
  * **URN do Módulo**

A autenticação de transporte estabelece **somente identidade**, nunca autorização.

---

## 3. Modelo de Autorização Baseado em Leases

### 3.1 Modelo Mental de Lease

Um lease é entendido como um:

> **Mandado Criptográfico de uma Conexão Entre um Core e um Módulo, juntamente com Ações Permitidas realizadas através dela**

Um lease DEVE conter:

* ID de Conexão (ID do Lease)
* Identidade do consumidor (Core / URN da Instância do Core)
* Identidade do provedor (URN do Módulo)
* Métodos de capacidade permitidos (escopo)
* Tempo de expiração
  *(limitado pela duração máxima declarada no Contrato de Capacidade do Módulo)*

---

### 3.2 Autoridade de Lease (Invariante Crítica)

> **O Core é a única e canônica autoridade capaz de emitir, renovar, modificar ou revogar leases.**

Módulos:

* NÃO DEVEM emitir, estender ou modificar leases
* PODEM apenas reconhecer, aplicar ou recusar execução com base em um lease emitido pelo Core

Isso remove toda simetria de autorização e previne comportamento split-brain.

---

### 3.3 Handshake e Estabelecimento de Lease

1. Um canal mTLS seguro é estabelecido.
2. O Core inicia um handshake declarando intenção e capacidades solicitadas.
3. O Módulo responde com **atestação apenas**:
   * Identidade
   * Hash do contrato de capacidade
   * Tipo de módulo declarado
   * Duração máxima de lease permitida
4. O Core valida a atestação **off-wire**.
5. Se aceito, o Core emite uma **Concessão de Lease assinada**.
6. O Módulo reconhece o lease e o vincula ao estado interno.

> **Um lease se torna válido somente após reconhecimento explícito pelo Módulo.**

---

### 3.4 Épocas de Lease e Anti-Dessincronização

Cada lease inclui uma **Época de Lease monotônica**.

* Épocas começam em `1` e são incrementadas em:

  * Renovação
  * Mudança de escopo
  * Revogação
* O Core é a única autoridade de época.

**Toda requisição DEVE carregar prova criptográfica vinculada a:**

* ID do Lease
* Época do Lease
* ID da Requisição / nonce

Requisições com épocas obsoletas ou incompatíveis DEVEM ser rejeitadas imediatamente.

Isso previne:

* Ataques de repetição
* Dessincronização silenciosa
* Falhas de revogação parcial

---

### 3.5 Validade de Lease e Disciplina de Relógio

* A expiração do lease é avaliada usando:

  * Uma tolerância limitada de desvio de relógio
  * Renovações periódicas conduzidas pelo Core
* Módulos DEVEM tratar expiração conservadoramente:

  * Se a validade é incerta → execução é recusada

Não há **confiança implícita** em relógios de parede locais.

---

### 3.6 Semântica de Revogação de Lease

* A revogação de lease pelo Core é autoritativa e final.
* Qualquer recusa explícita de comunicação por qualquer lado DEVE:

  * Invalidar imediatamente o lease localmente
  * Acionar tratamento de revogação no Core

Não existe estado de lease "meio-válido".

---

### 3.7 Promoção e Rebaixamento de Escopo de Lease

O escopo do lease define o **conjunto exato de métodos de capacidade** que um Módulo está autorizado a executar para um dado Core.
O escopo **não é estático**, mas a **expansão de escopo é estritamente controlada**.

> **O escopo só pode mudar através de uma atualização de lease explicitamente emitida pelo Core.**

---

#### 3.7.1 Autoridade e Direcionalidade

* Somente o **Core** pode conceder, promover ou rebaixar o escopo de lease.
* Módulos NÃO DEVEM ampliar escopo autonomamente.

---
#### 3.7.2 Atualização de Escopo via Incremento de Época de Lease

Se o Core requerer uma mudança de escopo:

* Uma **nova época de lease** DEVE ser emitida
* O escopo atualizado DEVE substituir completamente o escopo anterior
* A época anterior é imediatamente inválida

O Core emite uma **Atualização de Lease** assinada contendo:

* ID do Lease
* Nova Época de Lease
* Escopo permitido completo
* Tempo de expiração (inalterado ou encurtado)
* Restrições de execução opcionais

---

#### 3.7.3 Regras de Aplicação do Módulo

Ao receber uma atualização de lease, o Módulo DEVE:

* Validar assinatura do Core
* Verificar monotonicidade de época
* Substituir atomicamente seu contexto de lease local
* Rejeitar **todas as requisições** portando a época antiga

Se uma promoção de escopo ocorrer durante execução:

* A execução DEVE continuar **somente se** o método em andamento permanecer dentro de ambos:

  * Escopo antigo
  * Escopo novo
* Caso contrário, a execução DEVE parar no próximo ponto de interrupção

---

#### 3.7.6 Rebaixamento de Escopo e Redução de Emergência

O Core PODE rebaixar escopo a qualquer momento, incluindo:

* Incidentes de segurança
* Mudanças de política
* Comportamento inadequado observado

Rebaixamento:

* Entra em vigor imediatamente após incremento de época
* Não requer reconhecimento do Módulo para ser aplicado

---

#### 3.7.7 Invariantes de Segurança

> * Um Módulo nunca pode executar um método de capacidade que não foi explicitamente concedido na **época de lease atual**.
> * Promoção de escopo **nunca é implícita**, **nunca é cumulativa**, e **nunca é simétrica**.
> * Toda mudança de escopo é auditável e segura contra repetição.

---

#### 3.7.8 Semântica de Falha

Se:

* Uma atualização de escopo é perdida
* Épocas divergem
* Ou a validade é incerta

Então:

> **O Módulo DEVE falhar fechado e recusar execução.**

---

## 4. Contrato de Interface de Capacidade

* Cada Módulo DEVE expor uma interface de serviço gRPC estritamente definida e estática.
* Métodos expostos DEVEM corresponder exatamente aos métodos de capacidade declarados.
* Invocação reflexiva, dinâmica ou ad-hoc é proibida.
* Contratos de capacidade DEVEM declarar:

  * Classe de efeito colateral (puro / reversível / irreversível)
  * Garantias de abortabilidade

---

## 5. Estado de Lease-Zero

### 5.1 Definição

Um Módulo está em **Estado de Lease-Zero** quando não possui um lease atualmente válido.

Isso ocorre em:

* Expiração de lease
* Revogação de lease
* Perda de conexão
* Falha ao estabelecer um lease dentro de uma janela de inicialização limitada

---

### 5.2 Invariante do Core

> **Sem Lease, Sem Execução**

Um módulo sem lease válido:

* DEVE rejeitar toda execução de capacidade
* NÃO DEVE realizar efeitos colaterais
* NÃO DEVE processar tarefas em segundo plano em nome de um Core

---


## 6. Tipos de Módulos e Semântica de Ciclo de Vida

Todo Módulo ANIMA DEVE declarar **exatamente um Tipo de Módulo** em seu Contrato de Capacidade.

> **Um Tipo de Módulo é uma declaração de primeira classe de tenancy, autoridade de ciclo de vida, semântica de falha e garantias de isolamento.**

O Tipo de Módulo **não é uma dica de otimização** — é um **contrato rígido** aplicado pelo Core, ferramentas e política.

Um Módulo DEVE ser rejeitado se seu comportamento em tempo de execução contradiz seu tipo declarado.

---

### 6.1 Declaração de Tipo de Módulo (Normativa)

Cada Contrato de Capacidade de Módulo DEVE declarar, no mínimo:

* `module_type` 
* `tenancy_model`
* `lifecycle_authority`
* `lease_dependency`
* `state_persistence_policy`
* `side_effect_policy`

Essas declarações são **autoritativas** e DEVEM ser validadas durante o handshake.

---

### 6.2 Tipo I — Módulo Privado Efêmero

#### 6.2.1 Definição Declarativa

**Módulos Tipo I são:**

* **Efêmeros**
* **Mono-inquilino**
* **Estritamente vinculados a lease**
* **Controlados pelo ciclo de vida do Core**

Eles existem *apenas* para servir uma **única instância de Core pela duração de um lease ativo**.

> Um módulo Tipo I não tem significado fora de um lease válido.

---

#### 6.2.2 Propriedades Declarativas

| Propriedade            | Valor                                  |
| ---------------------- | -------------------------------------- |
| Modelo de tenancy      | Core Único                             |
| Autoridade de ciclo    | Core                                   |
| Dependência de lease   | Obrigatória                            |
| Efeitos colaterais     | Devem ser reversíveis ou proibidos     |
| Modo de inicialização  | Somente emitido pelo Core              |

---

#### 6.2.3 Semântica de Ciclo de Vida

* O Core é a **única autoridade** permitida para iniciar o módulo.
* O módulo DEVE aceitar leases de **exatamente um URN de Instância de Core** definido na inicialização.
* Estado de Lease-Zero leva inevitavelmente a término gracioso após um Período de Graça de Recuperação de Tarefa.
* Períodos de Graça de Recuperação de Tarefa:

  * DEVEM ser limitados
  * NÃO DEVEM ser renováveis
  * DEVEM rejeitar todo tráfego sem lease

> **Um módulo Tipo I sem um lease é considerado morto, mesmo se seu processo ainda estiver em execução.**

---

### 6.3 Tipo II — Módulo Privado Residente

#### 6.3.1 Definição Declarativa

**Módulos Tipo II são:**

* **Residentes**
* **Mono-inquilino**
* **Protegidos por lease**
* **Afiliados ao Core**

Eles são processos de longa duração que servem **exatamente um Core**, mas cuja existência não está estritamente vinculada à duração do lease.

---

#### 6.3.2 Propriedades Declarativas

| Propriedade            | Valor                                |
| ---------------------- | ------------------------------------ |
| Modelo de tenancy      | Core Único                           |
| Autoridade de ciclo    | Core ou Infraestrutura               |
| Dependência de lease   | Obrigatória para execução            |
| Efeitos colaterais     | Permitidos dentro do escopo de lease |
| Modo de inicialização  | Emitido pelo Core ou pré-iniciado    |

---

#### 6.3.3 Semântica de Ciclo de Vida

* O módulo DEVE se vincular permanentemente a um único URN de Core.
* Estado de Lease-Zero coloca o módulo em **Modo Standby**.
* Em Modo Standby:

  * Execução é proibida
  * Qualquer execução é interrompida no próximo ponto de interrupção declarado, de acordo com suas garantias de abortabilidade.
* Restauração e criação de lease DEVEM vir do mesmo Core.
* Qualquer estado de tarefa em andamento PODE ser retido apenas pela duração do Período de Graça de Recuperação de Tarefa.


> **Um módulo Tipo II sem um lease está inerte, não terminado.**

---

### 6.4 Tipo III — Módulo Residente Compartilhado

#### 6.4.1 Definição Declarativa

**Módulos Tipo III são:**

* **Residentes**
* **Multi-inquilino**
* **Particionados por lease**
* **Governados por infraestrutura**

Eles são projetados para servir com segurança **múltiplos Cores independentes concorrentemente**.

> Tipo III é uma **classe de confiança opt-in**, não um padrão.

---

#### 6.4.2 Propriedades Declarativas

| Propriedade            | Valor                         |
| ---------------------- | ----------------------------- |
| Modelo de tenancy      | Multi-Core                    |
| Autoridade de ciclo    | Infraestrutura                |
| Dependência de lease   | Obrigatória por inquilino     |
| Efeitos colaterais     | Somente isolados por lease    |
| Modo de inicialização  | Emitido pela infraestrutura   |

---

#### 6.4.3 Semântica de Isolamento e Comportamento

* Cada Core DEVE ser isolado por:

  * ID de Lease
  * URN do Core
* Todo comportamento DEVE estar no escopo de um lease ativo.
* Presença ou comportamento de um Core NÃO DEVE afetar outro.
* Estado do Período de Graça de Recuperação de Tarefa DEVE ser isolado por ID de Lease e destruído independentemente.

> **Qualquer influência entre inquilinos é considerada uma violação de segurança. E causará Lista Negra do Módulo.**

Verificações regulares de conformidade e verificação formal podem ser exigidas para módulos Tipo III pelas equipes ANIMA, a fim de garantir adesão estrita às garantias de isolamento.

---

#### 6.4.4 Semântica de Ciclo de Vida

* Expiração de lease afeta apenas o Core proprietário.
* Transição para Lease-Zero global coloca o módulo em Modo Standby, semelhante ao Tipo II.
* Término é controlado exclusivamente por infraestrutura ou administradores.

---

### 6.5 Configurações Inválidas (Normativa)

As seguintes combinações são **inválidas** e DEVEM ser rejeitadas:

* Qualquer módulo gravando estado persistente por mais tempo que um Período de Graça de Recuperação de Tarefa
* Qualquer módulo permitindo efeitos colaterais sem aplicação de lease
* Qualquer módulo executando lógica de capacidade sem um lease
* Qualquer módulo cujo comportamento observado contradiz seu tipo declarado

---

### 6.6 Invariante de Design

> **Tipo de Módulo é um limite de segurança, não um detalhe de implementação.**

Mudar o tipo de um módulo é uma **mudança quebrável** requerendo:

* Atualização de contrato de capacidade
* Revisão de política
* Reimplantação
  
 
## 7. Governança e Segurança do Tipo III

Módulos Tipo III operam sob **governança explícita** e requisitos de segurança:

Eles DEVEM fornecer:

* Garantias de determinismo
* Auto-testes de isolamento
* Aplicação de comportamento com escopo de lease
* Hooks de auditoria

Violações resultam em:

* Revogação imediata de lease
* Lista negra
* Reimplantação obrigatória ou sandboxing

Módulos de terceiros DEVEM passar verificações formais de conformidade ou executar em sandboxes fornecidos pelo ANIMA.

---

## 8. Persistência de Estado e Períodos de Graça de Recuperação de Tarefa

Ausência de estado no ANIMA significa a ausência de estado durável entre leases ou reinicializações.
Não proíbe efeitos colaterais transitórios que são totalmente atribuíveis a um único lease e explicitamente declarados no contrato de capacidade.

Módulos ANIMA devem ser arquiteturalmente sem estado.
Todo comportamento observável deve ser atribuível a entradas explícitas, um lease ativo e computação determinística. Estado retido durante o Período de Graça de Recuperação de Tarefa NÃO DEVE acionar nova execução ou efeitos colaterais.

Todos os módulos DEVEM ser projetados sem persistência de estado além do seguinte:
* Estado em memória durante tarefas ativas
* Armazenamento efêmero com escopo de leases ativos
* Recursos somente leitura pesados de inicialização carregados na inicialização, tais recursos DEVEM ser determinísticos, imutáveis e idênticos entre reinicializações.
* Caches devem ser:
  * com escopo de uma única execução de tarefa, ou
  * com escopo de um único lease ativo e destruídos na expiração do lease.

Armazenamento de estado persistente entre reinicializações ou ciclos de lease é proibido.

Períodos de Graça de Recuperação de Tarefa DEVEM ser:
* Um intervalo limitado durante o qual o estado de tarefa em andamento pode ser retido apenas para suportar rollback, retry ou relatório de erro para um único lease.
* Não renovável e não estendível.
* Não acessível para novos leases ou tarefas.

---
## 9. Observabilidade e Segurança de Canal Lateral

* Observabilidade é obrigatória mas **com escopo de lease**.
* Traces, métricas e logs DEVEM:

  * Nunca expor correlações de tempo entre inquilinos
  * Ser isolados por Core / Lease
* Módulos compartilhados DEVEM ocultar metadados identificadores de inquilino.

Observabilidade NÃO DEVE se tornar um canal de informação.

---

## Consequências

### Positivas

* Única fonte de verdade de autorização
* Execução segura contra repetição e determinística
* Limites de contenção explícitos
* Forte isolamento multi-inquilino
* Falha-seguro por padrão

### Negativas

* Maior rigor de implementação
* Maior carga de conformidade para módulos compartilhados

---

## Resumo


> **Módulos ANIMA são Privados Efêmeros (Tipo I), Privados Residentes (Tipo II), ou Residentes Compartilhados (Tipo III).**
> **Toda execução é protegida por leases criptográficos emitidos pelo Core sobre mTLS.**
> **Sem um lease válido, um módulo está inerte ou morto. Não há exceções.**
> **Mudanças de escopo são explícitas, auditáveis e unidirecionais.**
> **Tipos de módulos definem semântica estrita de ciclo de vida e tenancy.**
> **Persistência de estado é proibida além de Períodos de Graça de Recuperação de Tarefa limitados.**
