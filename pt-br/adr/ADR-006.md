# ADR-006: Regras de Dependência e Compartilhamento de Domínio

**Status:** Aceito  
**Data:** 2026-01-04  
**Decisores:** @Richard Rosenblat  
**Contexto:** Arquitetura Hexagonal, Domain-Driven Design (DDD), Python  

---

## Contexto

A ANIMA segue **Arquitetura Hexagonal** combinada com **Domain-Driven Design (DDD)**. À medida que o sistema cresce, a ambiguidade em torno de *o que os domínios podem compartilhar* e *como as dependências podem fluir* cria risco arquitetural.

Python aumenta esse risco devido a:

* Encapsulamento fraco no nível de módulo
* Fácil acesso a implementações concretas
* Falta de limites aplicados por padrão

Este ADR formaliza **regras estritas e explícitas** que governam:

* Dependências de domínio para domínio
* O que pode ser compartilhado
* Quando implementações concretas podem cruzar limites de domínio
* Como a conexão em runtime deve ocorrer

O objetivo é **clareza, consistência e manutenibilidade a longo prazo**.

---

### Decisão

Domínios **não compartilham código livremente**.
Domínios podem depender apenas de outros domínios através de **contratos públicos explícitos**.

Todo uso entre domínios deve se enquadrar em **uma das formas de dependência aprovadas** definidas abaixo.

Qualquer coisa não explicitamente permitida é **proibida por padrão**.

---

### Formas de Dependência Entre Domínios Aprovadas

Um domínio pode expor o seguinte como parte de sua **API pública**:

#### 1. Funções Livres (Lógica de Domínio Sem Estado)

Usadas para:

* Regras determinísticas
* Análise, validação, geração
* Transformações de valor

**Características:**

* Puras ou quase puras
* Sem ciclo de vida
* Sem IO externo

**Exemplo (domínio URN):**

```python
## domains/urn/generate.py

def generate_urn() -> URN:
    ...
```

```python
## domains/core/process.py
from domains.urn import generate_urn

class CoreProcess:
    def __init__(self) -> None:
        self.urn = generate_urn()
```

✔ Permitido

---

#### 2. Wrappers de Tipo Primitivo / Objetos de Valor

Usados para codificar **significado semântico** e prevenir uso indevido de primitivos.

**Exemplos:**

* `URN`
* `ExecutionId`
* `TraceId`
* `ParsedURN`

```python
## domains/urn/types.py
from typing import NewType

URN = NewType("URN", str)
```

✔ Permitido

Objetos de valor são seguros para importar diretamente entre domínios.

---

#### 3. Classes Base (Conceitualmente Abstratas)

Classes base definem **invariantes e contratos**.

##### 3.1 Classes Base Comportamentais → DEVEM ser Abstratas

Usadas quando:

* Outros domínios especializam comportamento
* A classe não deve ser instanciada

```python
from abc import ABC, abstractmethod

class BaseProcess(ABC):
    @abstractmethod
    def run(self) -> None:
        ...
```

✔ Permitido

---

##### 3.2 Classes Base de Exceção → PODEM ser Concretas

Exceções são **valores**, não comportamentos.

Elas:

* Devem ser instanciáveis
* Codificam semântica de domínio
* São explicitamente projetadas para herança

```python
class DomainError(Exception):
    pass

class URNError(DomainError):
    pass
```

✔ Permitido

Esta é uma exceção intencional às regras de abstração.

---


##### 3.3 Tradução de Erro Entre Domínios (Obrigatória)

Quando um domínio depende de outro domínio e invoca sua API pública, **erros específicos do domínio originados da dependência NÃO DEVEM vazar sem modificação**.

Em vez disso:

* O domínio consumidor **DEVE capturar** erros do domínio de dependência
* O domínio consumidor **DEVE lançar seu próprio erro específico de domínio**
* O erro lançado **DEVE herdar do tipo de erro original**
* O erro lançado **DEVE preservar a exceção original como causa**

Isso garante:

* Cada domínio permanece a **autoridade semântica** sobre seus próprios modos de falha
* O significado do erro é **reformulado na linguagem do domínio consumidor**
* Linhagem de exceção e capacidade de captura são preservadas

###### Exemplo

```python
# domains/urn/errors.py
class URNError(DomainError):
    pass
```

```python
# domains/order/errors.py
from domains.urn.errors import URNError

class OrderURNResolutionError(URNError):
    pass
```

```python
# domains/order/service.py
from domains.urn import generate_urn
from domains.urn.errors import URNError
from domains.order.errors import OrderURNResolutionError

def create_order() -> None:
    try:
        urn = generate_urn()
    except URNError as exc:
        raise OrderURNResolutionError(
            "Failed to generate URN during order creation"
        ) from exc
```

✔ Permitido
✔ Requerido
✔ Explícito

---


#### 4. Interfaces / Protocolos

Usadas quando:

* Comportamento deve ser fornecido externamente
* Múltiplas implementações são possíveis
* Conexão em runtime é necessária

```python
from typing import Protocol

class Clock(Protocol):
    def now(self) -> datetime: ...
```

```python
class CoreProcess:
    def __init__(self, clock: Clock):
        self.clock = clock
```

✔ Permitido

Domínios dependem de **interfaces**, não implementações.

---

### Implementações Concretas Entre Domínios

Implementações concretas podem cruzar limites de domínio **apenas nos seguintes casos**:

#### Caso 1 — Objetos de Valor

Imutáveis, autocontidos, sem ciclo de vida.

✔ Sempre permitido

---

#### Caso 2 — Erros

Classes de exceção concretas são explicitamente permitidas para serem compartilhadas e herdadas.

Porém:

* **Erros originados de outro domínio não devem escapar do domínio consumidor sem modificação**
* Domínios **devem traduzir erros de dependência** em seus próprios erros específicos de domínio
* O erro traduzido **deve herdar do tipo de erro original**

✔ Permitido
✔ Requerido para limites entre domínios

---

#### Caso 3 — Serviços de Domínio Autoritativos

Se um domínio é a **autoridade semântica** sobre um comportamento, outros domínios podem importar sua implementação concreta.

**Exemplo:**

* Geração de URN pertence exclusivamente ao domínio URN

```python
from domains.urn import generate_urn
```

✔ Permitido **apenas se**:

* A implementação é intencionalmente pública
* O comportamento é estável
* Nenhum estado de runtime ou IO está envolvido

---

### Práticas Proibidas Entre Domínios

❌ Importar módulos internos ou helpers privados  
❌ Compartilhar estado mutável entre domínios  
❌ Importar implementações de infraestrutura diretamente  
❌ Dependências circulares de domínio  
❌ Conexão em runtime dentro da lógica de domínio  

Exemplo (PROIBIDO):

```python
from domains.storage.postgres import PostgresRepository
```

---

### Regras de Camada Compartilhada

Algumas abstrações não pertencem a nenhum domínio.

```
/shared
  #types.py        # ExecutionId, TraceId
  #protocols.py    # Clock, Logger, EventSink
  #base.py         # Classes base abstratas
```

Regras:

* Domínios podem depender de `shared`
* `shared` não depende de nada

---

### Responsabilidades do Runtime

Runtime é responsável por:

* Instanciar implementações concretas
* Conectar dependências
* Selecionar estratégias

Domínios:

* Nunca devem instanciar infraestrutura
* Nunca devem selecionar implementações

---

### Regras Resumidas (Não Negociáveis)

1. Domínios compartilham **contratos**, não internos
2. Contratos podem ser:

   * Funções
   * Objetos de valor
   * Classes base abstratas
   * Interfaces / protocolos
3. Erros são instanciáveis e herdáveis
4. Implementações concretas cruzam domínios apenas se forem:

   * Valores
   * Erros
   * Serviços autoritativos puros
5. Runtime monta o sistema
6. Erros de domínio de dependências DEVEM ser capturados e relançados como erros específicos de domínio que herdam o tipo de erro original
---

## Consequências

* Limites arquiteturais fortes
* Acoplamento acidental reduzido
* Grafo de dependências previsível
* Testes e refatoração mais fáceis
* Rigor inicial aumentado

Este rigor é intencional e necessário.

---

## Princípio Final

> **Domínios não dependem de implementações.
> Eles dependem de significado.**

Significado é expresso através de contratos.
