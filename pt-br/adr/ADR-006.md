# ADR-006: Domain Dependency & Sharing Rules

**Status:** Accepted  
**Date:** 2026-01-04  
**Deciders:** @Richard Rosenblat  
**Context:** Hexagonal Architecture, Domain-Driven Design (DDD), Python  

---

## Context

ANIMA follows **Hexagonal Architecture** combined with **Domain-Driven Design (DDD)**. As the system grows, ambiguity around *what domains are allowed to share* and *how dependencies may flow* creates architectural risk.

Python increases this risk due to:

* Weak encapsulation at the module level
* Easy access to concrete implementations
* Lack of enforced boundaries by default

This ADR formalizes **strict, explicit rules** governing:

* Domain-to-domain dependencies
* What may be shared
* When concrete implementations may cross domain boundaries
* How runtime wiring must occur

The goal is **clarity, consistency, and long-term maintainability**.

---

### Decision

Domains **do not share code freely**.
Domains may only depend on other domains through **explicit public contracts**.

All cross-domain usage must fall into **one of the approved dependency forms** defined below.

Anything not explicitly allowed is **forbidden by default**.

---

### Approved Cross-Domain Dependency Forms

A domain may expose the following as part of its **public API**:

#### 1. Free Functions (Stateless Domain Logic)

Used for:

* Deterministic rules
* Parsing, validation, generation
* Value transformations

**Characteristics:**

* Pure or near-pure
* No lifecycle
* No external IO

**Example (URN domain):**

```python
## domains/urn/generate.py

def generate_urn() -> URN:
    ...
```

```python
## domains/core/process.py
from domains.urn import generate_urn

class CoreProcess:
    def __init__(self) -> None:
        self.urn = generate_urn()
```

✔ Allowed

---

#### 2. Primitive Type Wrappers / Value Objects

Used to encode **semantic meaning** and prevent misuse of primitives.

**Examples:**

* `URN`
* `ExecutionId`
* `TraceId`
* `ParsedURN`

```python
## domains/urn/types.py
from typing import NewType

URN = NewType("URN", str)
```

✔ Allowed

Value objects are safe to import directly across domains.

---

#### 3. Base Classes (Conceptually Abstract)

Base classes define **invariants and contracts**.

##### 3.1 Behavioral Base Classes → MUST be Abstract

Used when:

* Other domains specialize behavior
* The class is not meant to be instantiated

```python
from abc import ABC, abstractmethod

class BaseProcess(ABC):
    @abstractmethod
    def run(self) -> None:
        ...
```

✔ Allowed

---

##### 3.2 Exception Base Classes → MAY be Concrete

Exceptions are **values**, not behaviors.

They:

* Must be instantiable
* Encode domain semantics
* Are explicitly designed for inheritance

```python
class DomainError(Exception):
    pass

class URNError(DomainError):
    pass
```

✔ Allowed

This is an intentional exception to abstraction rules.

---


##### 3.3 Cross-Domain Error Translation (Mandatory)

When a domain depends on another domain and invokes its public API, **domain-specific errors originating from the dependency MUST NOT leak unmodified**.

Instead:

* The consuming domain **MUST catch** dependency domain errors
* The consuming domain **MUST raise its own domain-specific error**
* The raised error **MUST inherit from the original error type**
* The raised error **MUST preserve the original exception as the cause**

This ensures:

* Each domain remains the **semantic authority** over its own failure modes
* Error meaning is **reframed in the consuming domain’s language**
* Exception lineage and catchability are preserved

###### Example

```python
# domains/urn/errors.py
class URNError(DomainError):
    pass
```

```python
# domains/order/errors.py
from domains.urn.errors import URNError

class OrderURNResolutionError(URNError):
    pass
```

```python
# domains/order/service.py
from domains.urn import generate_urn
from domains.urn.errors import URNError
from domains.order.errors import OrderURNResolutionError

def create_order() -> None:
    try:
        urn = generate_urn()
    except URNError as exc:
        raise OrderURNResolutionError(
            "Failed to generate URN during order creation"
        ) from exc
```

✔ Allowed
✔ Required
✔ Explicit

---


#### 4. Interfaces / Protocols

Used when:

* Behavior must be supplied externally
* Multiple implementations are possible
* Runtime wiring is required

```python
from typing import Protocol

class Clock(Protocol):
    def now(self) -> datetime: ...
```

```python
class CoreProcess:
    def __init__(self, clock: Clock):
        self.clock = clock
```

✔ Allowed

Domains depend on **interfaces**, not implementations.

---

### Concrete Implementations Across Domains

Concrete implementations may cross domain boundaries **only in the following cases**:

#### Case 1 — Value Objects

Immutable, self-contained, no lifecycle.

✔ Always allowed

---

#### Case 2 — Errors

Concrete exception classes are explicitly allowed to be shared and inherited.

However:

* **Errors originating from another domain must not escape the consuming domain unmodified**
* Domains **must translate dependency errors** into their own domain-specific errors
* The translated error **must inherit from the original error type**

✔ Allowed
✔ Required for cross-domain boundaries

---

#### Case 3 — Authoritative Domain Services

If a domain is the **semantic authority** over a behavior, other domains may import its concrete implementation.

**Example:**

* URN generation belongs exclusively to the URN domain

```python
from domains.urn import generate_urn
```

✔ Allowed **only if**:

* The implementation is intentionally public
* The behavior is stable
* No runtime state or IO is involved

---

### Forbidden Cross-Domain Practices

❌ Importing internal modules or private helpers  
❌ Sharing mutable state across domains  
❌ Importing infrastructure implementations directly  
❌ Circular domain dependencies  
❌ Runtime wiring inside domain logic  

Example (FORBIDDEN):

```python
from domains.storage.postgres import PostgresRepository
```

---

### Shared Layer Rules

Some abstractions do not belong to any domain.

```
/shared
  #types.py        # ExecutionId, TraceId
  #protocols.py    # Clock, Logger, EventSink
  #base.py         # Abstract base classes
```

Rules:

* Domains may depend on `shared`
* `shared` depends on nothing

---

### Runtime Responsibilities

Runtime is responsible for:

* Instantiating concrete implementations
* Wiring dependencies
* Selecting strategies

Domains:

* Must never instantiate infrastructure
* Must never select implementations

---

### Summary Rules (Non-Negotiable)

1. Domains share **contracts**, not internals
2. Contracts may be:

   * Functions
   * Value objects
   * Abstract base classes
   * Interfaces / protocols
3. Errors are instantiable and inheritable
4. Concrete implementations cross domains only if they are:

   * Values
   * Errors
   * Pure authoritative services
5. Runtime assembles the system
6. Domain errors from dependencies MUST be caught and re-raised as domain-specific errors that inherit the original error type
---

## Consequences

* Strong architectural boundaries
* Reduced accidental coupling
* Predictable dependency graph
* Easier testing and refactoring
* Increased upfront rigor

This rigor is intentional and required.

---

## Final Principle

> **Domains do not depend on implementations.
> They depend on meaning.**

Meaning is expressed through contracts.
