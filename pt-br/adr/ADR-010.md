# ADR-010: Divisão Adaptador–Atuador com Fronteira de Processo Estrita (Sem Código de Terceiros no Núcleo)

**Status:** Aceito  
**Data:** 2026-01-07  
**Decisores:** @RichardRosenblat  
**Contexto:** Segurança, Isolamento, Arquitetura Hexagonal, DDD

---

## Contexto

ANIMA integra Módulos externos para perceber entradas e executar efeitos colaterais. Designs iniciais consideravam carregar Python de propriedade de módulo no Núcleo para tradução ("adaptadores"). Isso é uma violação de segurança: o Núcleo nunca deve executar código de terceiros.

Para preservar segurança e fronteiras hexagonais enquanto mantém os Módulos práticos para distribuir, dividimos responsabilidades de módulo e aplicamos uma fronteira de processo estrita.

---

## Decisão

Todo Módulo é dividido em duas partes, ambas executando fora do processo do Núcleo:

- Adaptador — Tradução pura e validação de schema
- Atuador — Execução com efeitos que toca APIs/hardware

O Núcleo nunca carrega ou executa código de propriedade de módulo. Toda interação Núcleo ↔ Módulo ocorre via gRPC com mTLS e leases emitidos pelo Núcleo (ADR-003).

---

## Definições

### Adaptador (Lado do Módulo, Tradução Pura)
- Caminho de entrada: mapeia sinais capturados → eventos de entrada do Núcleo 
- Caminho de saída: mapeia Intenção do Núcleo (URN de capacidade + payload) → schema de comando do módulo
- Responsabilidades:
  - tradução determinística
  - validação de JSON Schema contra o contrato de capacidade
  - aplicação de escopo de lease em chamadas de saída
- Proibições:
  - sem planejamento, sem política
  - sem I/O externo além de gRPC para o Núcleo ou invocação de atuador local
  - sem acesso à memória ou internos do Núcleo

### Atuador (Lado do Módulo, Execução com Efeitos)
- Executa efeitos colaterais do mundo real (APIs, hardware, plataformas)
- Aplica políticas de escopo de lease e interrupção (ADR-005)
- Emite eventos de observabilidade com envelope ADR-004
- Contém zero lógica ou raciocínio do Núcleo

---

## Fronteira de Processo (Invariante)

- Núcleo executa apenas código confiável, de propriedade do motor.
- Adaptadores e Atuadores executam em processos de propriedade do módulo.
- Toda comunicação usa gRPC sobre mTLS com identidades atestadas (URN do Núcleo, URN do Módulo) e leases emitidos pelo Núcleo (ADR-003).
- Sem imports dinâmicos, plugins ou execução de Python de módulos dentro do Núcleo.

---

## Propriedade de PLN em Módulos de Linguagem Natural

Módulos que lidam com entrada e saída de linguagem natural PODEM enviar uma implementação de PLN ou delegar responsabilidades de PLN ao Arcuate do Núcleo (ADR-009). Esta escolha deve preservar isolamento de processo e a divisão Adaptador–Atuador.

### Entrada de Linguagem Natural
- Opção A — PLN de propriedade do módulo:
  - O Adaptador do módulo realiza PLN local para transformar input.nl → eventos input.semantic.
  - Restrições:
    - Apenas tradução; sem planejamento ou política
    - Incluir confiança e proveniência em payloads semânticos
    - Sem acesso à memória do Núcleo; proveniência reflete "module"
- Opção B — Delegar ao Arcuate:
  - O Adaptador do módulo publica eventos input.nl para o Núcleo.
  - O Arcuate do Núcleo consome input.nl e produz input.semantic; Núcleo raciocina sobre eventos semânticos.
  - Restrições:
    - Adaptador permanece puro; sem PLN incorporado
    - Fronteira de processo preservada; sem código de plugin no Núcleo

### Saída de Linguagem Natural (ex., TTS, entrega de chat)
- Opção A — GNL de propriedade do módulo:
  - O Adaptador do módulo mapeia intenções do Núcleo para schemas de comando de saída e realiza GNL local (realização de superfície) antes da execução do Atuador (ex., síntese TTS, envio de mensagem).
  - Restrições:
    - GNL é tradução; sem planejamento, sem acesso à memória
    - Eventos de observabilidade DEVEM capturar intenção, metadados de realização e resultado de execução
- Opção B — Delegar ao Arcuate:
  - O Núcleo produz a superfície linguística via Arcuate a partir do conteúdo semântico de uma intenção.
  - O Adaptador do módulo traduz o texto realizado no comando do módulo; o Atuador executa (ex., falar/enviar).
  - Restrições:
    - Adaptador permanece puro; Atuador realiza efeitos colaterais
    - Uso do Arcuate segue regras de isolamento ADR-009

Em todos os casos:
- Adaptadores permanecem mapeamento puro + validação.
- Atuadores realizam IO e efeitos sob leases válidos (ADR-003).
- Eventos semânticos DEVEM incluir campos de confiança e proveniência (ADR-011).
- Linguagem natural NÃO DEVE acionar execução direta; o pipeline permanece Entrada → Interpretação → Intenção → Validação/Confirmação → Execução (Modelo de Segurança).

---

## Protocolo & Contratos

- Entrada (Módulo → Núcleo): Adaptador publica eventos de entrada e tipos de evento.
- Saída (Núcleo → Módulo): Núcleo chama Adaptador via um Gateway de Capacidade genérico:
  - capability_urn + schema_version + payload (validado pelo adaptador)
  - LeaseMeta (lease_id, epoch) e ExecMeta (execution/trace/span)
- Contrato de Capacidade:
  - JSON Schemas declarativos para payloads de comando
  - classe de efeito colateral do método (reversível/irreversível)
  - política de interrupção (soft-stop/hard-stop/checkpoint/non-interruptible)
  - duração máxima de lease

---

## Invariantes de Segurança

- Sem código de plugin no Núcleo — nunca.
- Toda execução de módulo requer um lease válido com epoch atual (ADR-003).
- Promoção/rebaixamento de escopo ocorre apenas via atualizações de lease emitidas pelo Núcleo.
- Estado Zero-Lease: módulos estão inertes (Type II standby ou Type I terminate).
- Adaptadores não podem ampliar escopo ou contornar proteção do Núcleo.

---

## Observabilidade

- Adaptadores e Atuadores emitem eventos estruturados conforme ADR-004:
  - execution_id, trace_id, span_id, thread_id, timestamp
  - instance_urn, core_urn
  - source=module:<name> e type=
  - payload=apenas campos estruturados
- Sem logs de texto livre como autoridade; eventos são a fonte da verdade.

---

## Padrão de Empacotamento (De Propriedade do Módulo, Organizado em Camadas Limpas)

Um módulo pode distribuir Adaptador e Atuador juntos enquanto preserva pureza:

- adapter/
  - input/  (sinais → eventos input.*; mapeamento puro)
  - output/ (intenção → comandos; mapeamento puro + validação de schema)
- actuator/ (execução com efeitos: APIs/hardware)
- capability_contract/ (JSON Schemas + manifesto)
- transport/ (servidor/cliente gRPC; mTLS; aplicação de lease)
- proto/ (IDL para CapabilityGateway e serviços Adapter)

---

## Consequências

### Positivas
- Elimina risco de injeção de código no Núcleo
- Preserva fronteiras hexagonais e testabilidade
- Divisão clara de responsabilidades (traduzir vs executar)
- Forte auditabilidade via eventos estruturados

### Tradeoffs
- Requer disciplina estrita de schema e validação de manifesto
- Ligeiramente mais fiação (gRPC + ciclo de vida de lease)

---

## ADRs Relacionados

- ADR-003 — Protocolo Núcleo ↔ Módulo, tipos de módulo, leases
- ADR-004 — Modelo de observabilidade e envelope de evento
- ADR-005 — Modelo de interrupção & preempção
- ADR-007 — Regras de infraestrutura & adaptador
- ADR-011 — Arquitetura de entrada baseada em eventos

---

## Declaração Final

Núcleo raciocina e supervisiona. Módulos adaptam e agem.  
Sem código de terceiros executa dentro do Núcleo.
