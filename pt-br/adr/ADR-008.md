# ADR-008: ANIMA Core Behaves as a Cognitive Kernel with Multitasking and Interruptible Execution

**Status:** Accepted
**Date:** 2026-01-05
**Deciders:** @RichardRosenblat
**Context:** Long-lived behavior, concurrency, interruptions, architectural clarity

---

## Context

ANIMA is not a request–response chatbot.
It is a long-lived, stateful cognitive system that must:

* Run multiple behaviors concurrently
* Maintain awareness across time
* React to external events while tasks are in progress
* Safely interrupt, pause, cancel, or replace ongoing actions
* Remain observable, auditable, and explainable

Early designs that treated the Core as a “main loop” or orchestration script proved insufficient:

* Blocking execution prevents responsiveness
* Implicit async behavior hides state transitions
* Cancellation via hard task termination risks corruption
* Ad-hoc interruption logic becomes untestable and unsafe

To support **human-compatible interaction**, ANIMA must reason and act more like an operating system than a script.

---

## Decision

The ANIMA Core is formally defined as a **Cognitive Kernel**.

The Core MUST:

* Manage concurrent, long-lived tasks
* Treat actions as supervised execution units
* Support cooperative interruption and cancellation
* Never block on task execution
* Centralize scheduling, supervision, and state transitions

Tasks are not function calls.
They are **managed processes** under kernel supervision.

---

## Definition

### Cognitive Kernel Responsibilities

The ANIMA Core, acting as a kernel, is responsible for:

* Task lifecycle management (spawn, run, pause, cancel, complete)
* Interrupt routing and arbitration
* Event dispatch and prioritization
* Capability-aware execution control
* Resource-aware scheduling
* Observability and audit logging
* Safe interaction between cognition, language, and embodiment

The Core does not “do work” directly.
It **supervises work**.

---

### Tasks as Managed Execution Units

A task in ANIMA is an execution of a plan that contains multiple action intent objects and contigencies.

Tasks are:
* Explicitly created
* Identifiable
* Observable
* Interruptible
* Cooperative in its execution

Tasks MUST:

* Expose lifecycle state
* Periodically check for control signals
* Terminate cleanly when interrupted
* Never assume uninterrupted execution

This mirrors operating system process semantics, not traditional async calls.

---

### Cooperative Interruption Model

ANIMA adopts **cooperative interruption**, not forceful termination.

The Kernel MAY:

* Signal pause
* Signal cancellation
* Signal priority change

Tasks MUST decide:

* When it is safe to pause
* How to clean up resources
* How to terminate gracefully

This guarantees:

* Resource safety
* Predictable behavior
* Explainable state transitions

---

### Kernel vs User Space

The Core enforces a strict separation:

* **Kernel space**

  * Task scheduling
  * Memory access mediation
  * Capability enforcement
  * AI model invocation
  * Interrupt routing

* **User space (Modules / Tasks)**

  * Domain-specific logic
  * IO and side effects (via capabilities)
  * Cooperative task execution

Modules MUST NOT:

* Manage concurrency independently
* Interrupt other tasks directly
* Access kernel internals
* Bypass supervision

---

## Multitasking Model

The Kernel MUST support concurrent execution of:

* Cognitive planning
* Natural language processing
* Listening / sensing tasks
* Speaking / embodiment tasks
* Monitoring or background behaviors

Multitasking is **first-class**, not incidental.

The Kernel remains responsive even while tasks are running.

---

## Interrupt Semantics

Interruptions are:

* Explicit
* Intent-driven
* Observable
* Reversible when possible

Examples:

* User speaks while ANIMA is speaking
* Higher-priority task supersedes a lower-priority one
* Capability is revoked mid-execution
* Environmental event invalidates a plan

Interruptions are routed through the Kernel, never directly between tasks.

---

## Constraints and Invariants

The following constraints are architectural invariants:

* The Core MUST never block on task execution
* All long-lived behavior MUST be task-based
* All interruptions MUST pass through the Kernel
* Tasks MUST be interruptible by design
* State transitions MUST be observable and logged
* No module may unilaterally control execution flow

These constraints ensure safety, predictability, and debuggability.

---

## Consequences

### Positive

* Enables natural, human-like interaction
* Supports real-time responsiveness
* Makes interruption safe and explainable
* Allows complex behavior composition
* Simplifies reasoning about system state
* Aligns cognition, language, and embodiment under one supervisor

---

### Trade-offs

* Increases architectural complexity
* Requires disciplined task design
* Requires explicit lifecycle modeling
* Makes “quick hacks” impossible by design

These trade-offs are intentional and necessary for ANIMA’s goals.

---

## Rationale

Human interaction is interrupt-driven, concurrent, and contextual.

A system that cannot pause, reconsider, or reprioritize **cannot behave intelligently in real environments**.

By adopting a kernel model:

* ANIMA gains temporal awareness
* Behavior becomes composable
* Safety becomes enforceable
* Intelligence becomes sustainable over time

---

## Future Work

* Formalize task priority and scheduling policies
* Define task preemption heuristics
* Implement kernel-level resource accounting
* Create tooling for task introspection and replay
* Document best practices for cooperative task design

---

### Final Statement

> **ANIMA does not execute instructions.
> It supervises behavior.**

That is the defining property of its Core.
